
tcc_ddr.o:     file format elf32-littlearm
tcc_ddr.o
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .text.func_sdram_init 00000698  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .text.ddr_self_refresh_exit 000000a0  00000000  00000000  000006cc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .text._change_mem_clock 00000410  00000000  00000000  0000076c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text.ddr_self_refresh_enter 000000d4  00000000  00000000  00000b7c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .text.InitRoutine_Start 000006c0  00000000  00000000  00000c50  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text.InitRoutine_End 00000004  00000000  00000000  00001310  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .text.copy_dram_param 00000004  00000000  00000000  00001314  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .text.copy_dram_init 00000050  00000000  00000000  00001318  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.change_mem_clock 00000700  00000000  00000000  00001368  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .rodata.str1.1 0000005d  00000000  00000000  00001a68  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 13 .debug_info   000027b0  00000000  00000000  00001ac5  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 14 .debug_abbrev 0000040f  00000000  00000000  00004275  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00001198  00000000  00000000  00004684  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 16 .debug_aranges 00000060  00000000  00000000  0000581c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 17 .debug_ranges 00000418  00000000  00000000  0000587c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 18 .debug_line   00000632  00000000  00000000  00005c94  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 19 .debug_str    00000b13  00000000  00000000  000062c6  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .comment      00000031  00000000  00000000  00006dd9  2**0
                  CONTENTS, READONLY
 21 .note.GNU-stack 00000000  00000000  00000000  00006e0a  2**0
                  CONTENTS, READONLY
 22 .ARM.attributes 0000002d  00000000  00000000  00006e0a  2**0
                  CONTENTS, READONLY
 23 .debug_frame  000000ec  00000000  00000000  00006e38  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 tcc_ddr.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .text.func_sdram_init	00000000 .text.func_sdram_init
00000000 l    d  .text.ddr_self_refresh_exit	00000000 .text.ddr_self_refresh_exit
00000000 l    d  .text._change_mem_clock	00000000 .text._change_mem_clock
00000000 l    d  .text.ddr_self_refresh_enter	00000000 .text.ddr_self_refresh_enter
00000000 l    d  .text.InitRoutine_Start	00000000 .text.InitRoutine_Start
00000000 l    d  .text.InitRoutine_End	00000000 .text.InitRoutine_End
00000000 l    d  .text.copy_dram_param	00000000 .text.copy_dram_param
00000000 l    d  .text.copy_dram_init	00000000 .text.copy_dram_init
00000000 l    d  .text.change_mem_clock	00000000 .text.change_mem_clock
00000000 l    d  .rodata.str1.1	00000000 .rodata.str1.1
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .note.GNU-stack	00000000 .note.GNU-stack
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text.func_sdram_init	00000698 func_sdram_init
00000000 g     F .text.ddr_self_refresh_exit	000000a0 ddr_self_refresh_exit
00000000 g     F .text._change_mem_clock	00000410 _change_mem_clock
00000000 g     F .text.ddr_self_refresh_enter	000000d4 ddr_self_refresh_enter
00000000 g     F .text.InitRoutine_Start	000006c0 InitRoutine_Start
00000000 g     F .text.InitRoutine_End	00000004 InitRoutine_End
00000000 g     F .text.copy_dram_param	00000004 copy_dram_param
00000000 g     F .text.copy_dram_init	00000050 copy_dram_init
00000000         *UND*	00000000 memcpy
00000000         *UND*	00000000 __aeabi_uidiv
00000000 g     F .text.change_mem_clock	000006fc change_mem_clock
00000000         *UND*	00000000 tcc_find_pms
00000000         *UND*	00000000 printf



Disassembly of section .text.func_sdram_init:

00000000 <func_sdram_init>:
/*===========================================================================
* FUNCTION : void func_sdram_init(void)
* DESCRIPTION : copy these codes of function at sram for kenel. Device use them when it wake up.
===========================================================================*/
void func_sdram_init(void)
{
   0:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
inline static void ddr_clock_set(void)
{
	volatile int i;

	/* Change CLKCTRL soruce to XIN */
	writel(0x00001F00, addr_clk(0x000000));		// CPU (Cortex-A7)
   4:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
   8:	e3a02c1f 	mov	r2, #7936	; 0x1f00
   c:	e5832000 	str	r2, [r3]
	writel(0x00001F00, addr_clk(0x000008));		// Memory Bus	
  10:	e5832008 	str	r2, [r3, #8]
	writel(0x00200014, addr_clk(0x000014));		// io bus
  14:	e59f25e4 	ldr	r2, [pc, #1508]	; 600 <func_sdram_init+0x600>
  18:	e5832014 	str	r2, [r3, #20]
	writel(0x00200014, addr_clk(0x000024));		// smu bus
  1c:	e5832024 	str	r2, [r3, #36]	; 0x24
	writel(0x00200014, addr_clk(0x00002C));		// cortex-M4	
  20:	e583202c 	str	r2, [r3, #44]	; 0x2c

	/* enable hsio block */
	writel(0x00000001, (void __iomem *)addr_clk(0x400100));           // pmu pwrup_hsbus
  24:	e2833501 	add	r3, r3, #4194304	; 0x400000
  28:	e3a02001 	mov	r2, #1
  2c:	e5832100 	str	r2, [r3, #256]	; 0x100
	while((readl((void __iomem *)addr_clk(0x400000)) & 0x1) == 0);       // check pwrsts0 0-bit
  30:	e5932000 	ldr	r2, [r3]
  34:	e3120001 	tst	r2, #1
  38:	0afffffc 	beq	30 <func_sdram_init+0x30>
	writel(readl((void __iomem *)addr_clk(0x400010))|(1<<31), \
  3c:	e5932010 	ldr	r2, [r3, #16]
  40:	e3822102 	orr	r2, r2, #-2147483648	; 0x80000000
  44:	e59f35b8 	ldr	r3, [pc, #1464]	; 604 <func_sdram_init+0x604>
  48:	e5832010 	str	r2, [r3, #16]
			(void __iomem *)addr_clk(0x400010));     // pmu_sysrst
	writel(readl((void __iomem *)addr_mem(0x810000))|(1<<29), \
  4c:	e24338bf 	sub	r3, r3, #12517376	; 0xbf0000
  50:	e5932000 	ldr	r2, [r3]
  54:	e3822202 	orr	r2, r2, #536870912	; 0x20000000
  58:	e5832000 	str	r2, [r3]
			(void __iomem *)addr_mem(0x810000));  // membus_hclk
	writel(readl((void __iomem *)addr_mem(0x810004))|(1<<12), \
  5c:	e5932004 	ldr	r2, [r3, #4]
  60:	e3822a01 	orr	r2, r2, #4096	; 0x1000
  64:	e5832004 	str	r2, [r3, #4]
			(void __iomem *)addr_mem(0x810004));  // membus_rst
	writel(0x00200014, (void __iomem *)addr_clk(0x000020));           // hsio bus
  68:	e59f2590 	ldr	r2, [pc, #1424]	; 600 <func_sdram_init+0x600>
  6c:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
  70:	e5832020 	str	r2, [r3, #32]

inline static void ddr_setpll(void __iomem *reg, unsigned value)
{
	unsigned int i;
	if (value & (1<<31)) {
		writel((value&0x7FFFFFFF)|(1<<26), reg);
  74:	e59f258c 	ldr	r2, [pc, #1420]	; 608 <func_sdram_init+0x608>
  78:	e583204c 	str	r2, [r3, #76]	; 0x4c
		for (i=100 ; i ; i--);
		writel(readl(reg) | (1<<31), reg);
  7c:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
  80:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
  84:	e3a0231d 	mov	r2, #1946157056	; 0x74000000
  88:	e582304c 	str	r3, [r2, #76]	; 0x4c
  8c:	e3a03064 	mov	r3, #100	; 0x64
		for (i=100 ; i ; i--)
			while ((readl(reg) & (1<<26)) == 0);
  90:	e592104c 	ldr	r1, [r2, #76]	; 0x4c
  94:	e3110301 	tst	r1, #67108864	; 0x4000000
  98:	0afffffc 	beq	90 <func_sdram_init+0x90>
	unsigned int i;
	if (value & (1<<31)) {
		writel((value&0x7FFFFFFF)|(1<<26), reg);
		for (i=100 ; i ; i--);
		writel(readl(reg) | (1<<31), reg);
		for (i=100 ; i ; i--)
  9c:	e2533001 	subs	r3, r3, #1
  a0:	1afffffa 	bne	90 <func_sdram_init+0x90>

inline static void ddr_setpll(void __iomem *reg, unsigned value)
{
	unsigned int i;
	if (value & (1<<31)) {
		writel((value&0x7FFFFFFF)|(1<<26), reg);
  a4:	e59f2560 	ldr	r2, [pc, #1376]	; 60c <func_sdram_init+0x60c>
  a8:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
  ac:	e5832050 	str	r2, [r3, #80]	; 0x50
		for (i=100 ; i ; i--);
		writel(readl(reg) | (1<<31), reg);
  b0:	e5933050 	ldr	r3, [r3, #80]	; 0x50
  b4:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
  b8:	e3a0231d 	mov	r2, #1946157056	; 0x74000000
  bc:	e5823050 	str	r3, [r2, #80]	; 0x50
  c0:	e3a03064 	mov	r3, #100	; 0x64
		for (i=100 ; i ; i--)
			while ((readl(reg) & (1<<26)) == 0);
  c4:	e5921050 	ldr	r1, [r2, #80]	; 0x50
  c8:	e3110301 	tst	r1, #67108864	; 0x4000000
  cc:	0afffffc 	beq	c4 <func_sdram_init+0xc4>
	unsigned int i;
	if (value & (1<<31)) {
		writel((value&0x7FFFFFFF)|(1<<26), reg);
		for (i=100 ; i ; i--);
		writel(readl(reg) | (1<<31), reg);
		for (i=100 ; i ; i--)
  d0:	e2533001 	subs	r3, r3, #1
  d4:	1afffffa 	bne	c4 <func_sdram_init+0xc4>

inline static void ddr_setpll(void __iomem *reg, unsigned value)
{
	unsigned int i;
	if (value & (1<<31)) {
		writel((value&0x7FFFFFFF)|(1<<26), reg);
  d8:	e59f2530 	ldr	r2, [pc, #1328]	; 610 <func_sdram_init+0x610>
  dc:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
  e0:	e5832048 	str	r2, [r3, #72]	; 0x48
		for (i=100 ; i ; i--);
		writel(readl(reg) | (1<<31), reg);
  e4:	e5933048 	ldr	r3, [r3, #72]	; 0x48
  e8:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
  ec:	e3a0231d 	mov	r2, #1946157056	; 0x74000000
  f0:	e5823048 	str	r3, [r2, #72]	; 0x48
  f4:	e3a03064 	mov	r3, #100	; 0x64
		for (i=100 ; i ; i--)
			while ((readl(reg) & (1<<26)) == 0);
  f8:	e5921048 	ldr	r1, [r2, #72]	; 0x48
  fc:	e3110301 	tst	r1, #67108864	; 0x4000000
 100:	0afffffc 	beq	f8 <func_sdram_init+0xf8>
	unsigned int i;
	if (value & (1<<31)) {
		writel((value&0x7FFFFFFF)|(1<<26), reg);
		for (i=100 ; i ; i--);
		writel(readl(reg) | (1<<31), reg);
		for (i=100 ; i ; i--)
 104:	e2533001 	subs	r3, r3, #1
 108:	1afffffa 	bne	f8 <func_sdram_init+0xf8>

	/* PLLs */
	ddr_setpll((void __iomem *)addr_clk(0x00004C), (1<<31)|PLL3_VALUE); // for cpu
	ddr_setpll((void __iomem *)addr_clk(0x000050), (1<<31)|PLL4_VALUE); // for mem
	ddr_setpll((void __iomem *)addr_clk(0x000048), (1<<31)|PLL2_VALUE); 
	i=3200; while(i--);
 10c:	e3a03d32 	mov	r3, #3200	; 0xc80
 110:	e58d3000 	str	r3, [sp]
 114:	e59d3000 	ldr	r3, [sp]
 118:	e3530000 	cmp	r3, #0
 11c:	e2432001 	sub	r2, r3, #1
 120:	e58d2000 	str	r2, [sp]
 124:	1afffffa 	bne	114 <func_sdram_init+0x114>
		writel(readl(reg) & ~(1<<31), reg);
}

inline static void ddr_setfbus(void __iomem *reg, unsigned value)
{
	writel(value, reg);
 128:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
 12c:	e3012f01 	movw	r2, #7937	; 0x1f01
 130:	e5832000 	str	r2, [r3]
	while(readl(reg) & (1<<29));
 134:	e5932000 	ldr	r2, [r3]
 138:	e3120202 	tst	r2, #536870912	; 0x20000000
 13c:	1afffffc 	bne	134 <func_sdram_init+0x134>
		writel(readl(reg) & ~(1<<31), reg);
}

inline static void ddr_setfbus(void __iomem *reg, unsigned value)
{
	writel(value, reg);
 140:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
 144:	e3012f01 	movw	r2, #7937	; 0x1f01
 148:	e5832008 	str	r2, [r3, #8]
	while(readl(reg) & (1<<29));
 14c:	e1a02003 	mov	r2, r3
 150:	e5923008 	ldr	r3, [r2, #8]
 154:	e3130202 	tst	r3, #536870912	; 0x20000000
 158:	1afffffc 	bne	150 <func_sdram_init+0x150>
		writel(readl(reg) & ~(1<<31), reg);
}

inline static void ddr_setfbus(void __iomem *reg, unsigned value)
{
	writel(value, reg);
 15c:	e59f24b0 	ldr	r2, [pc, #1200]	; 614 <func_sdram_init+0x614>
 160:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
 164:	e5832014 	str	r2, [r3, #20]
	while(readl(reg) & (1<<29));
 168:	e1a02003 	mov	r2, r3
 16c:	e5923014 	ldr	r3, [r2, #20]
 170:	e3130202 	tst	r3, #536870912	; 0x20000000
 174:	1afffffc 	bne	16c <func_sdram_init+0x16c>
		writel(readl(reg) & ~(1<<31), reg);
}

inline static void ddr_setfbus(void __iomem *reg, unsigned value)
{
	writel(value, reg);
 178:	e59f2494 	ldr	r2, [pc, #1172]	; 614 <func_sdram_init+0x614>
 17c:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
 180:	e5832020 	str	r2, [r3, #32]
	while(readl(reg) & (1<<29));
 184:	e1a02003 	mov	r2, r3
 188:	e5923020 	ldr	r3, [r2, #32]
 18c:	e3130202 	tst	r3, #536870912	; 0x20000000
 190:	1afffffc 	bne	188 <func_sdram_init+0x188>
		writel(readl(reg) & ~(1<<31), reg);
}

inline static void ddr_setfbus(void __iomem *reg, unsigned value)
{
	writel(value, reg);
 194:	e59f2478 	ldr	r2, [pc, #1144]	; 614 <func_sdram_init+0x614>
 198:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
 19c:	e5832024 	str	r2, [r3, #36]	; 0x24
	while(readl(reg) & (1<<29));
 1a0:	e1a02003 	mov	r2, r3
 1a4:	e5923024 	ldr	r3, [r2, #36]	; 0x24
 1a8:	e3130202 	tst	r3, #536870912	; 0x20000000
 1ac:	1afffffc 	bne	1a4 <func_sdram_init+0x1a4>
		writel(readl(reg) & ~(1<<31), reg);
}

inline static void ddr_setfbus(void __iomem *reg, unsigned value)
{
	writel(value, reg);
 1b0:	e59f245c 	ldr	r2, [pc, #1116]	; 614 <func_sdram_init+0x614>
 1b4:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
 1b8:	e583202c 	str	r2, [r3, #44]	; 0x2c
	while(readl(reg) & (1<<29));
 1bc:	e1a02003 	mov	r2, r3
 1c0:	e592302c 	ldr	r3, [r2, #44]	; 0x2c
 1c4:	e3130202 	tst	r3, #536870912	; 0x20000000
 1c8:	1afffffc 	bne	1c0 <func_sdram_init+0x1c0>
	ddr_setfbus((void __iomem *)addr_clk(0x000008), 0x00001F01);	// Memory Bus
	ddr_setfbus((void __iomem *)addr_clk(0x000014), 0x00200012);	// io bus
	ddr_setfbus((void __iomem *)addr_clk(0x000020), 0x00200012);    // hsio bus
	ddr_setfbus((void __iomem *)addr_clk(0x000024), 0x00200012);	// smu bus
	ddr_setfbus((void __iomem *)addr_clk(0x00002C), 0x00200012);	// cortex-M4
	i=3200; while(i--);
 1cc:	e3a03d32 	mov	r3, #3200	; 0xc80
 1d0:	e58d3000 	str	r3, [sp]
 1d4:	e59d3000 	ldr	r3, [sp]
 1d8:	e3530000 	cmp	r3, #0
 1dc:	e2432001 	sub	r2, r3, #1
 1e0:	e58d2000 	str	r2, [sp]
 1e4:	1afffffa 	bne	1d4 <func_sdram_init+0x1d4>

	writel(0x24000000, addr_clk(0x0000D4));		// sdmmc0 peri (24MHz)	// for emmcboot
 1e8:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
 1ec:	e3a02309 	mov	r2, #603979776	; 0x24000000
 1f0:	e58320d4 	str	r2, [r3, #212]	; 0xd4
	writel(0x24000000, addr_clk(0x0000D8));		// sdmmc1 peri (24MHz)	// for emmcboot
 1f4:	e58320d8 	str	r2, [r3, #216]	; 0xd8
	writel(0x24000000, addr_clk(0x0000DC));		// sdmmc2 peri (24MHz)	// for emmcboot
 1f8:	e58320dc 	str	r2, [r3, #220]	; 0xdc
	writel(0x24000000, addr_clk(0x0000E0));		// sdmmc3 peri (24MHz)	// for emmcboot
 1fc:	e58320e0 	str	r2, [r3, #224]	; 0xe0
	i=3200; while(i--);
 200:	e3a03d32 	mov	r3, #3200	; 0xc80
 204:	e58d3000 	str	r3, [sp]
 208:	e59d3000 	ldr	r3, [sp]
 20c:	e3530000 	cmp	r3, #0
 210:	e2432001 	sub	r2, r3, #1
 214:	e58d2000 	str	r2, [sp]
 218:	1afffffa 	bne	208 <func_sdram_init+0x208>
	nCL = 9;
	nCWL = 7;
#endif

// PHY Setting
	dmc0_phy(0x5C) = 0x1; // UNIQUIFY_IO_1
 21c:	e59f33f4 	ldr	r3, [pc, #1012]	; 618 <func_sdram_init+0x618>
 220:	e3a02001 	mov	r2, #1
 224:	e5832170 	str	r2, [r3, #368]	; 0x170
	while(!(dmc0_phy(0x5c)&0x2));
 228:	e5931170 	ldr	r1, [r3, #368]	; 0x170
 22c:	e59f23e4 	ldr	r2, [pc, #996]	; 618 <func_sdram_init+0x618>
 230:	e3110002 	tst	r1, #2
 234:	0afffffb 	beq	228 <func_sdram_init+0x228>
	dmc0_phy(0x5C) = 0x5;	
 238:	e3a03005 	mov	r3, #5

	temp = dmc0_phy(0x5C);

	for(i=0 ; i<MEM_STRB_WIDTH ; i++)
	{
		dmc0_phy(0x4B) = SLV_DLY_WIDTH*i;
 23c:	e3a0c006 	mov	ip, #6
		if(TRIM1 < 0)
			temp = temp & ~(1<<i);
	else
			temp = temp | (1<<i);
		dmc0_phy(0x59) = temp;
		dmc0_phy(0x4c) = abs(TRIM1);
 240:	e1a04003 	mov	r4, r3
		if(TRIM3 < 0)
			temp = temp & ~(1<<i);
		else
			temp = temp | (1<<i);
		dmc0_phy(0x5A) = temp;
		dmc0_phy(0x4E) = abs(TRIM3);
 244:	e3a05008 	mov	r5, #8
#endif

// PHY Setting
	dmc0_phy(0x5C) = 0x1; // UNIQUIFY_IO_1
	while(!(dmc0_phy(0x5c)&0x2));
	dmc0_phy(0x5C) = 0x5;	
 248:	e5823170 	str	r3, [r2, #368]	; 0x170
	dmc0_phy(0x5C) = 0x1;	
 24c:	e3a01001 	mov	r1, #1
 250:	e5821170 	str	r1, [r2, #368]	; 0x170

	temp = dmc0_phy(0x5C);
 254:	e5920170 	ldr	r0, [r2, #368]	; 0x170

	for(i=0 ; i<MEM_STRB_WIDTH ; i++)
 258:	e3a00000 	mov	r0, #0
 25c:	e58d0004 	str	r0, [sp, #4]
 260:	e59d0004 	ldr	r0, [sp, #4]
 264:	e59f33ac 	ldr	r3, [pc, #940]	; 618 <func_sdram_init+0x618>
 268:	e3500003 	cmp	r0, #3
 26c:	ca000010 	bgt	2b4 <func_sdram_init+0x2b4>
	{
		dmc0_phy(0x4B) = SLV_DLY_WIDTH*i;
 270:	e59d3004 	ldr	r3, [sp, #4]
 274:	e003039c 	mul	r3, ip, r3
 278:	e582312c 	str	r3, [r2, #300]	; 0x12c

		temp = dmc0_phy(0x59);
 27c:	e5923164 	ldr	r3, [r2, #356]	; 0x164
		if(TRIM1 < 0)
			temp = temp & ~(1<<i);
 280:	e59d0004 	ldr	r0, [sp, #4]
 284:	e1c33011 	bic	r3, r3, r1, lsl r0
	else
			temp = temp | (1<<i);
		dmc0_phy(0x59) = temp;
 288:	e5823164 	str	r3, [r2, #356]	; 0x164
		dmc0_phy(0x4c) = abs(TRIM1);
 28c:	e5824130 	str	r4, [r2, #304]	; 0x130

		temp = dmc0_phy(0x5A);
 290:	e5923168 	ldr	r3, [r2, #360]	; 0x168
		if(TRIM3 < 0)
			temp = temp & ~(1<<i);
 294:	e59d0004 	ldr	r0, [sp, #4]
 298:	e1c33011 	bic	r3, r3, r1, lsl r0
		else
			temp = temp | (1<<i);
		dmc0_phy(0x5A) = temp;
 29c:	e5823168 	str	r3, [r2, #360]	; 0x168
		dmc0_phy(0x4E) = abs(TRIM3);
 2a0:	e5825138 	str	r5, [r2, #312]	; 0x138
	dmc0_phy(0x5C) = 0x5;	
	dmc0_phy(0x5C) = 0x1;	

	temp = dmc0_phy(0x5C);

	for(i=0 ; i<MEM_STRB_WIDTH ; i++)
 2a4:	e59d3004 	ldr	r3, [sp, #4]
 2a8:	e2833001 	add	r3, r3, #1
 2ac:	e58d3004 	str	r3, [sp, #4]
 2b0:	eaffffea 	b	260 <func_sdram_init+0x260>
		dmc0_phy(0x5A) = temp;
		dmc0_phy(0x4E) = abs(TRIM3);

	}

	dmc0_phy(0x6D) = (0<<20)|(0<<16)|1; // SCL_WINDOW_TRIM
 2b4:	e3a02001 	mov	r2, #1
	dmc0_phy(0x49) = ((0xA)<<28)|0x1000; // PHY_DLL_RECALIB
	dmc0_phy(0x57) = 0; //0x01000000; // UNQ_ANALOG_DLL_1


	dmc0_phy(0x48) = (0<<31)|(PREAMBLE_DLY<<29)|(1<<28)|(0<<24)|(0xf<<20)|(0xf<<16)|(0<<15)|(HALF_RATE_MODE<<14)|(0<<9)|(EXTRA_ONE_CLK<<8)|(MEMCTRL_DDS<<4)|MEMCTRL_TERM;
 2b8:	e59f135c 	ldr	r1, [pc, #860]	; 61c <func_sdram_init+0x61c>
		dmc0_phy(0x5A) = temp;
		dmc0_phy(0x4E) = abs(TRIM3);

	}

	dmc0_phy(0x6D) = (0<<20)|(0<<16)|1; // SCL_WINDOW_TRIM
 2bc:	e58321b4 	str	r2, [r3, #436]	; 0x1b4
	dmc0_phy(0x49) = ((0xA)<<28)|0x1000; // PHY_DLL_RECALIB
 2c0:	e59f2358 	ldr	r2, [pc, #856]	; 620 <func_sdram_init+0x620>
 2c4:	e5832124 	str	r2, [r3, #292]	; 0x124
	dmc0_phy(0x57) = 0; //0x01000000; // UNQ_ANALOG_DLL_1
 2c8:	e3a02000 	mov	r2, #0
 2cc:	e583215c 	str	r2, [r3, #348]	; 0x15c


	dmc0_phy(0x48) = (0<<31)|(PREAMBLE_DLY<<29)|(1<<28)|(0<<24)|(0xf<<20)|(0xf<<16)|(0<<15)|(HALF_RATE_MODE<<14)|(0<<9)|(EXTRA_ONE_CLK<<8)|(MEMCTRL_DDS<<4)|MEMCTRL_TERM;
 2d0:	e5831120 	str	r1, [r3, #288]	; 0x120
	// PHY_PAD_CTRL
	// reset_en_state, preamble_dly, receiver_en, clk_adjust_phy,clk_drive,adrctrl_drive,ddr1p2,half_rate,no_external_dll,extra_oen_clk,dq_dqs_drive,io_mode,odt_en,odt_sel

	dmc0_phy(0x46) = (1<<24)|(0<<16)|(0<<12)|(round_up(nCL,2)<<4)|(0<<3)|(1<<2)|(0<<1)|1;
 2d4:	e59f1348 	ldr	r1, [pc, #840]	; 624 <func_sdram_init+0x624>
 2d8:	e5831118 	str	r1, [r3, #280]	; 0x118
	// SCL_CONFIG_1
	// ddr_odt_ctl_wr, ddr_odt_ctrl_rd, local_odt_ctrl, rd_cas_latency, dly_dfi_phyupd_ack, ddr3, ddr2, burst8

	dmc0_phy(0x47) = (SWAP_PHASE<<31)|(0<<30)|(0<<29)|(0<<28)|(1<<25)|((HALF_RATE_MODE && (((nCWL%2==0)?1:0)^SWAP_PHASE))<<24)|(0<<12)|(round_up(nCWL,2)<<8)|1;
 2dc:	e59f1344 	ldr	r1, [pc, #836]	; 628 <func_sdram_init+0x628>
 2e0:	e583111c 	str	r1, [r3, #284]	; 0x11c
	// swap_phase,rdfifo_enable,lpddr2,analog_dll_for_scl,scl_step,size,dly_dfi_wrdata,double_ref_dly,wr_cas,latency,scl_test_cs

	dmc0_phy(0x6F) = ((nCWL%2==0) && SWAP_PHASE);
	// SCL_CONFIG_4

	dmc0_phy(0x54) = (((RTT_WR<<9)|((nCWL-5)<<3))<<16)|(((nCWL-5)<<3));
 2e4:	e59f1340 	ldr	r1, [pc, #832]	; 62c <func_sdram_init+0x62c>

	dmc0_phy(0x47) = (SWAP_PHASE<<31)|(0<<30)|(0<<29)|(0<<28)|(1<<25)|((HALF_RATE_MODE && (((nCWL%2==0)?1:0)^SWAP_PHASE))<<24)|(0<<12)|(round_up(nCWL,2)<<8)|1;
	// SCL_CONFIG_2
	// swap_phase,rdfifo_enable,lpddr2,analog_dll_for_scl,scl_step,size,dly_dfi_wrdata,double_ref_dly,wr_cas,latency,scl_test_cs

	dmc0_phy(0x6F) = ((nCWL%2==0) && SWAP_PHASE);
 2e8:	e58321bc 	str	r2, [r3, #444]	; 0x1bc
	// SCL_CONFIG_4

	dmc0_phy(0x54) = (((RTT_WR<<9)|((nCWL-5)<<3))<<16)|(((nCWL-5)<<3));
 2ec:	e5831150 	str	r1, [r3, #336]	; 0x150
	// WRLVL_DYN_ODT
	// dynamic_odt_on, dynamic_odt_off

	dmc0_phy(0x5B) = (~SCL_LANES&((1<<MEM_STRB_WIDTH)-1));
 2f0:	e583216c 	str	r2, [r3, #364]	; 0x16c
		//unsigned bit_lvl_wr_failure_status; // Read-only
		unsigned bit_lvl_wr_side_read_lat = (READ_LAT);
		unsigned bit_lvl_wr_side_trim_lat = (TRIM_LAT); 
		unsigned dynamic_write_bit_leveling = 0;

		dmc0_phy(0x70) =  (bit_lvl_wr_side_read_lat<<12)|(bit_lvl_wr_side_trim_lat<<4)|dynamic_write_bit_leveling;
 2f4:	e59f2334 	ldr	r2, [pc, #820]	; 630 <func_sdram_init+0x630>
 2f8:	e58321c0 	str	r2, [r3, #448]	; 0x1c0

	{
		unsigned wr_lvl_on = (1<<7)|(((RTT_NOM&0x4)<<7)|((RTT_NOM&0x2)<<5)|((RTT_NOM&0x1)<<2))|(((DIC&0x2)<<4)|((DIC&0x1)<<1));
		unsigned wr_lvl_off = (((RTT_NOM&0x4)<<7)|((RTT_NOM&0x2)<<5)|((RTT_NOM&0x1)<<2))|(((DIC&0x2)<<4)|((DIC&0x1)<<1));

		dmc0_phy(0x55) = (wr_lvl_on<<16)|(wr_lvl_off<<0);
 2fc:	e59f2330 	ldr	r2, [pc, #816]	; 634 <func_sdram_init+0x634>
 300:	e5832154 	str	r2, [r3, #340]	; 0x154
		unsigned mas_dll_dly = 0;
		unsigned mas_dll_dly_by_2 = 0;

		while(mas_dll_dly ==0)
		{
			mas_dll_dly = dmc0_phy(0x4A);
 304:	e5931128 	ldr	r1, [r3, #296]	; 0x128
 308:	e59f2308 	ldr	r2, [pc, #776]	; 618 <func_sdram_init+0x618>

	{
		unsigned mas_dll_dly = 0;
		unsigned mas_dll_dly_by_2 = 0;

		while(mas_dll_dly ==0)
 30c:	e1b01c21 	lsrs	r1, r1, #24
 310:	0afffffb 	beq	304 <func_sdram_init+0x304>
	}


		for(i=0 ; i<MEM_CLOCKS ; i++)
		{
			dmc0_phy(0x4B) = i*(SLV_DLY_WIDTH+1);
 314:	e3a01007 	mov	r1, #7
				if(DLLS_TRIM < 0)
					val = val & ~(1<<6);
				else
					val = val | (1<<6);

				dmc0_phy(0x69) = val;
 318:	e3a0004a 	mov	r0, #74	; 0x4a
		{
			mas_dll_dly = dmc0_phy(0x4A);
			mas_dll_dly = mas_dll_dly >> 24;
	}

		mas_dll_dly = dmc0_phy(0x4A);			
 31c:	e5923128 	ldr	r3, [r2, #296]	; 0x128
			if(DLLS_TRIM_ADRCTRL > 0)
				val = val | (1<<9);
			else
				val = val & (~(1<<9));
	
			dmc0_phy(0x4A) = val;
 320:	e3003205 	movw	r3, #517	; 0x205
 324:	e5823128 	str	r3, [r2, #296]	; 0x128
			else
				dmc0_phy(0x4A) = 0x200 | mas_dll_dly;
	}


		for(i=0 ; i<MEM_CLOCKS ; i++)
 328:	e3a03000 	mov	r3, #0
 32c:	e58d3004 	str	r3, [sp, #4]
 330:	e59d3004 	ldr	r3, [sp, #4]
 334:	e3530001 	cmp	r3, #1
 338:	e59f32d8 	ldr	r3, [pc, #728]	; 618 <func_sdram_init+0x618>
 33c:	ca000007 	bgt	360 <func_sdram_init+0x360>
		{
			dmc0_phy(0x4B) = i*(SLV_DLY_WIDTH+1);
 340:	e59d3004 	ldr	r3, [sp, #4]
 344:	e0030391 	mul	r3, r1, r3
 348:	e582312c 	str	r3, [r2, #300]	; 0x12c
				if(DLLS_TRIM < 0)
					val = val & ~(1<<6);
				else
					val = val | (1<<6);

				dmc0_phy(0x69) = val;
 34c:	e58201a4 	str	r0, [r2, #420]	; 0x1a4
			else
				dmc0_phy(0x4A) = 0x200 | mas_dll_dly;
	}


		for(i=0 ; i<MEM_CLOCKS ; i++)
 350:	e59d3004 	ldr	r3, [sp, #4]
 354:	e2833001 	add	r3, r3, #1
 358:	e58d3004 	str	r3, [sp, #4]
 35c:	eafffff3 	b	330 <func_sdram_init+0x330>
			if(DLLS_TRIM_ADRCTRL_MA > 0)
				val = val | (1<<27);
			else
				val = val & ~(1<<27);

			dmc0_phy(0x49) = MASTER_DLL | val;
 360:	e59f22d0 	ldr	r2, [pc, #720]	; 638 <func_sdram_init+0x638>
	dmc0_ctl(0x14) = (1<<6)|(0<<4)|(HALF_RATE_MODE<<3)|DRAM_MEM_WIDTH;

	for(i=0 ; i<NUM_AGENTS ; i++)
	{
		dmc0_ctl(0x0) = i*MIN_CMDACPT_WIDTH;
		dmc0_ctl(0x3) = 4;
 364:	e3a01004 	mov	r1, #4
			if(DLLS_TRIM_ADRCTRL_MA > 0)
				val = val | (1<<27);
			else
				val = val & ~(1<<27);

			dmc0_phy(0x49) = MASTER_DLL | val;
 368:	e5832124 	str	r2, [r3, #292]	; 0x124
		}

	}	


	dmc0_phy(0x43) = (SCL_WAIT_LATENCY<<12)|(ANALOG_DLL_FOR_SCL<<9)|(0<<8)|(MAIN_CLK_DLY<<4)|6;
 36c:	e3052076 	movw	r2, #20598	; 0x5076
 370:	e583210c 	str	r2, [r3, #268]	; 0x10c
	if(OP_DQS_TRIM_UPD)
		unq_set_op_dqs_trim(0);

// Controller set init value

	dmc0_ctl(0x14) = (1<<6)|(0<<4)|(HALF_RATE_MODE<<3)|DRAM_MEM_WIDTH;
 374:	e3a03048 	mov	r3, #72	; 0x48
 378:	e59f22bc 	ldr	r2, [pc, #700]	; 63c <func_sdram_init+0x63c>
 37c:	e5823050 	str	r3, [r2, #80]	; 0x50

	for(i=0 ; i<NUM_AGENTS ; i++)
 380:	e3a03000 	mov	r3, #0
 384:	e58d3004 	str	r3, [sp, #4]
 388:	e59d3004 	ldr	r3, [sp, #4]
 38c:	e3530001 	cmp	r3, #1
 390:	e59f32a4 	ldr	r3, [pc, #676]	; 63c <func_sdram_init+0x63c>
 394:	ca000007 	bgt	3b8 <func_sdram_init+0x3b8>
	{
		dmc0_ctl(0x0) = i*MIN_CMDACPT_WIDTH;
 398:	e59d3004 	ldr	r3, [sp, #4]
 39c:	e1a03183 	lsl	r3, r3, #3
 3a0:	e5823000 	str	r3, [r2]
		dmc0_ctl(0x3) = 4;
 3a4:	e582100c 	str	r1, [r2, #12]

// Controller set init value

	dmc0_ctl(0x14) = (1<<6)|(0<<4)|(HALF_RATE_MODE<<3)|DRAM_MEM_WIDTH;

	for(i=0 ; i<NUM_AGENTS ; i++)
 3a8:	e59d3004 	ldr	r3, [sp, #4]
 3ac:	e2833001 	add	r3, r3, #1
 3b0:	e58d3004 	str	r3, [sp, #4]
 3b4:	eafffff3 	b	388 <func_sdram_init+0x388>
		//unsigned mem_config_5;
		//int mode = 0;

		address_mapping(0);

		dmc0_ctl(0x5) = (en_auto_prech<<30)|(0<<29)|(col_addr_high_rshift<<24)|(0<<21)|(cs_addr_rshift<<16)|(0<<13)|(bank_addr_rshift<<8)|(0<<5)|row_addr_rshift;
 3b8:	e59f2280 	ldr	r2, [pc, #640]	; 640 <func_sdram_init+0x640>

		dmc0_ctl(0x16) = (0<<16)|2;
		// AUTO_SCL_CTRL

		#if defined(CONFIG_DDR3_2CS)
		dmc0_ctl(0x10) = 0*MEM_CHIP_SELECTS; // ODT_CONFIG
 3bc:	e3a01000 	mov	r1, #0
		//unsigned mem_config_5;
		//int mode = 0;

		address_mapping(0);

		dmc0_ctl(0x5) = (en_auto_prech<<30)|(0<<29)|(col_addr_high_rshift<<24)|(0<<21)|(cs_addr_rshift<<16)|(0<<13)|(bank_addr_rshift<<8)|(0<<5)|row_addr_rshift;
 3c0:	e5832014 	str	r2, [r3, #20]
		// MEM_CONFIG_1
		dmc0_ctl(0x6) = (dfi_dram_clk_disable<<21)|(dfi_init_start<<20)|(row_addr_mask<<0);
 3c4:	e3072fff 	movw	r2, #32767	; 0x7fff
 3c8:	e5832018 	str	r2, [r3, #24]
		// MEM_CONFIG_2
		dmc0_ctl(0x7) = (aprech_bit_pos<<16)|(col_addr_high_mask);
 3cc:	e59f2270 	ldr	r2, [pc, #624]	; 644 <func_sdram_init+0x644>
 3d0:	e583201c 	str	r2, [r3, #28]
		// MEM_CONFIG_3
		dmc0_ctl(0x8)  = col_addr_low_mask;
 3d4:	e3a02007 	mov	r2, #7
 3d8:	e5832020 	str	r2, [r3, #32]
		// MEM_CONFIG_4
		dmc0_ctl(0x9) = (bank_addr_high_rshift<<24)|(bank_addr_high_mask<<16)|(cs_addr_mask<<8)|(bank_addr_mask);
 3dc:	e2822b02 	add	r2, r2, #2048	; 0x800
 3e0:	e5832024 	str	r2, [r3, #36]	; 0x24
		// MEM_CONFIG_5
	}

	dmc0_ctl(0xB) = (0<<22)|(17<<12)|(0x3f<<4)|(0<<3)|(0<<2)|(0<<1)|0;
 3e4:	e59f225c 	ldr	r2, [pc, #604]	; 648 <func_sdram_init+0x648>
 3e8:	e583202c 	str	r2, [r3, #44]	; 0x2c
		tXP       = max(max(DDR3_tXP_ck, round_up(DDR3_tXP_ps, 2*tCK)), tCKE);
		sref_exit = HALF_RATE_MODE ? max(round_up(DDR3_tDLLK_ck, 2) - tXS, round_up(DDR3_tZQOPER_ck, 2))-2 :
		                               max(DDR3_tDLLK_ck               -tXS, DDR3_tZQOPER_ck             )-2 ;


		dmc0_ctl(0xA) = (1<<28)|(8<<24)|((round_up(DDR3_tRFC_ps, 2*tCK)-2)<<16)|(round_up(DDR3_tREFI_ps, 2*tCK)-2);
 3ec:	e59f2258 	ldr	r2, [pc, #600]	; 64c <func_sdram_init+0x64c>
 3f0:	e5832028 	str	r2, [r3, #40]	; 0x28
		//REF_CONFIG

		dmc0_ctl(0xC) = (rmw_dly<<28)|(rd2wr_dly<<24)|(wr2wr_csc_dly<<20)|(wr2wr_dly<<16)|(rd2rd_csc_dly<<12)|(rd2rd_dly<<8)|(wr2rd_csc_dly<<4)|wr2rd_dly;
 3f4:	e59f2254 	ldr	r2, [pc, #596]	; 650 <func_sdram_init+0x650>
 3f8:	e5832030 	str	r2, [r3, #48]	; 0x30
		// DLY_CONFIG_1

		dmc0_ctl(0xD) = (((sref_exit & (1<<8))>>8)<<30)|
 3fc:	e59f2250 	ldr	r2, [pc, #592]	; 654 <func_sdram_init+0x654>
 400:	e5832034 	str	r2, [r3, #52]	; 0x34
			//unsigned wr2prech_dly     = ret4(wr2prech_dly);
			unsigned rd2prech_dly     = (HALF_RATE_MODE ? (max(round_up(DDR3_tRTP_ps, 2*tCK), round_up(DDR3_tRTP_ck, 2)) - 1) :
			                                 (max(round_up(DDR3_tRTP_ps, 2*tCK), DDR3_tRTP_ck) - 1));
			unsigned prech_all_dly    = round_up(DDR3_tRP_ps, 2*tCK);

			dmc0_ctl(0xE) = (rd_burst_end_dly<<28)|(prech2ras_dly<<24)|(ras2cas_dly<<20)|(ras2ras_dly<<16)|(wr2prech_dly<<12)|(rd2prech_dly<<8)|(prech_all_dly<<0);
 404:	e59f224c 	ldr	r2, [pc, #588]	; 658 <func_sdram_init+0x658>
 408:	e5832038 	str	r2, [r3, #56]	; 0x38
			unsigned tfaw_dly = round_up(DDR3_tFAW_ps, 2*tCK)-1;
			unsigned ras2ras_same_bank_dly = round_up(DDR3_tRC_ps, 2*tCK)-1;
			unsigned swap_phase = SWAP_PHASE;
			unsigned ras2prech_dly = round_up(DDR3_tRAS_ps, 2*tCK)-1;

			dmc0_ctl(0xf) = ((zqc_dly<<24)|(tfaw_dly<<16)|(ras2ras_same_bank_dly<<8)|(swap_phase<<5)|(ras2prech_dly<<0));
 40c:	e59f2248 	ldr	r2, [pc, #584]	; 65c <func_sdram_init+0x65c>
 410:	e583203c 	str	r2, [r3, #60]	; 0x3c
			// DLY_CONFIG_4
		}

		dmc0_ctl(0x15) = ((tXS-1)<<24)|(ZQC_SHORT<<23)|(AUTO_ZQC_ENABLE<<22)|ZQC_INTERVAL;
 414:	e59f2244 	ldr	r2, [pc, #580]	; 660 <func_sdram_init+0x660>
 418:	e5832054 	str	r2, [r3, #84]	; 0x54
		// ZQC_CONFIG

		dmc0_ctl(0x16) = (0<<16)|2;
 41c:	e3a02002 	mov	r2, #2
 420:	e5832058 	str	r2, [r3, #88]	; 0x58
		// AUTO_SCL_CTRL

		#if defined(CONFIG_DDR3_2CS)
		dmc0_ctl(0x10) = 0*MEM_CHIP_SELECTS; // ODT_CONFIG
 424:	e5831040 	str	r1, [r3, #64]	; 0x40
		dmc0_ctl(0x13) = (3<<16)|2;			 // ODT_EN_CONFIG
 428:	e59f1234 	ldr	r1, [pc, #564]	; 664 <func_sdram_init+0x664>
 42c:	e583104c 	str	r1, [r3, #76]	; 0x4c
		dmc0_ctl(0x10) = 1*MEM_CHIP_SELECTS; // ODT_CONFIG
 430:	e5832040 	str	r2, [r3, #64]	; 0x40
		dmc0_ctl(0x13) = (3<<16)|1;			 // ODT_EN_CONFIG
 434:	e59f222c 	ldr	r2, [pc, #556]	; 668 <func_sdram_init+0x668>
 438:	e583204c 	str	r2, [r3, #76]	; 0x4c
			#endif
			unsigned odt_wr_set_dly = 1;
			unsigned odt_rd_set_dly = (HALF_RATE_MODE) ? ( (nCL - nCWL - (nCL - nCWL > 0 ? 1 : 0))/2 ) : (RL-WL);
			unsigned odt_en_sel =  0;			
	
			dmc0_ctl(0x10) = (odt_len_wr<<20)|(odt_len_rd<<16)|(odt_wr_set_dly<<12)|(odt_rd_set_dly<<8)|odt_en_sel;
 43c:	e59f2228 	ldr	r2, [pc, #552]	; 66c <func_sdram_init+0x66c>
 440:	e5832040 	str	r2, [r3, #64]	; 0x40
			// ODT_CONFIG
		}
	 
		dmc0_ctl(0x11) = (BIG_ENDIAN<<31)|(7<<28)|(3<<24)|((RL-3-C2D)<<16)|(0<<12)|(0<<8)|(0<<4)|(WL-C2D-1-(nCWL%2 == 0 && !SWAP_PHASE && HALF_RATE_MODE));
 444:	e59f2224 	ldr	r2, [pc, #548]	; 670 <func_sdram_init+0x670>
 448:	e5832044 	str	r2, [r3, #68]	; 0x44
		//DATA_XFR_CONFIG
	}


// dram init
	dmc0_ctl(0x4) = 1; // MEM_START
 44c:	e3a02001 	mov	r2, #1
 450:	e5832010 	str	r2, [r3, #16]
	dmc0_ctl(0x50/4) = 0x00000048;
 454:	e3a02048 	mov	r2, #72	; 0x48
 458:	e5832050 	str	r2, [r3, #80]	; 0x50
	if (!no_reset) {
		HOST_CMD_LOAD0(0, 0, CKE_LOW, round_up(max(10000, 5*tCK), wait_cycle));
		HOST_CMD_LOAD0(1, 0, CKE_LOW, 0);
	}

	dmc0_ctl(0x12) = 0x11; // HOST_CMD_ISSUE
 45c:	e3a02011 	mov	r2, #17
 460:	e5832048 	str	r2, [r3, #72]	; 0x48
//	while(dmc0_ctl(0x12)&0x10); //

	i=3200; while(i--);
 464:	e3a03d32 	mov	r3, #3200	; 0xc80
 468:	e58d3004 	str	r3, [sp, #4]
 46c:	e59d3004 	ldr	r3, [sp, #4]
 470:	e3530000 	cmp	r3, #0
 474:	e2432001 	sub	r2, r3, #1
 478:	e58d2004 	str	r2, [sp, #4]
 47c:	1afffffa 	bne	46c <func_sdram_init+0x46c>
#if defined(CONFIG_DRAM_16BIT_USED)
	dmc0_ctl(0x14) = 0x0000005A;
#else
	dmc0_ctl(0x14) = 0x00000058;
 480:	e59f31b4 	ldr	r3, [pc, #436]	; 63c <func_sdram_init+0x63c>
 484:	e3a02058 	mov	r2, #88	; 0x58
 488:	e5832050 	str	r2, [r3, #80]	; 0x50
#endif

	i=3200; while(i--);
 48c:	e3a02d32 	mov	r2, #3200	; 0xc80
 490:	e58d2004 	str	r2, [sp, #4]
 494:	e59d2004 	ldr	r2, [sp, #4]
 498:	e3520000 	cmp	r2, #0
 49c:	e2421001 	sub	r1, r2, #1
 4a0:	e58d1004 	str	r1, [sp, #4]
 4a4:	1afffffa 	bne	494 <func_sdram_init+0x494>
	i=3200; while(i--);
}

inline static void  HOST_CMD_LOAD0(unsigned a, unsigned b, unsigned c, unsigned d)
{
	(*(volatile unsigned long *)(0x73500080+a*4))=c; 
 4a8:	e3e024ff 	mvn	r2, #-16777216	; 0xff000000
 4ac:	e5832080 	str	r2, [r3, #128]	; 0x80
	(*(volatile unsigned long *)(0x735000C0+a*4))=((max(d,1)-1)<<12)|b;
 4b0:	e3a02a7d 	mov	r2, #512000	; 0x7d000
 4b4:	e58320c0 	str	r2, [r3, #192]	; 0xc0
	i=3200; while(i--);
}

inline static void  HOST_CMD_LOAD0(unsigned a, unsigned b, unsigned c, unsigned d)
{
	(*(volatile unsigned long *)(0x73500080+a*4))=c; 
 4b8:	e59f21b4 	ldr	r2, [pc, #436]	; 674 <func_sdram_init+0x674>
 4bc:	e5832084 	str	r2, [r3, #132]	; 0x84
	(*(volatile unsigned long *)(0x735000C0+a*4))=((max(d,1)-1)<<12)|b;
 4c0:	e3012202 	movw	r2, #4610	; 0x1202
 4c4:	e58320c4 	str	r2, [r3, #196]	; 0xc4
	i=3200; while(i--);
}

inline static void  HOST_CMD_LOAD0(unsigned a, unsigned b, unsigned c, unsigned d)
{
	(*(volatile unsigned long *)(0x73500080+a*4))=c; 
 4c8:	e59f21a8 	ldr	r2, [pc, #424]	; 678 <func_sdram_init+0x678>
 4cc:	e5832088 	str	r2, [r3, #136]	; 0x88
	(*(volatile unsigned long *)(0x735000C0+a*4))=((max(d,1)-1)<<12)|b;
 4d0:	e3a02c13 	mov	r2, #4864	; 0x1300
 4d4:	e58320c8 	str	r2, [r3, #200]	; 0xc8
	i=3200; while(i--);
}

inline static void  HOST_CMD_LOAD0(unsigned a, unsigned b, unsigned c, unsigned d)
{
	(*(volatile unsigned long *)(0x73500080+a*4))=c; 
 4d8:	e59f219c 	ldr	r2, [pc, #412]	; 67c <func_sdram_init+0x67c>
 4dc:	e583208c 	str	r2, [r3, #140]	; 0x8c
	(*(volatile unsigned long *)(0x735000C0+a*4))=((max(d,1)-1)<<12)|b;
 4e0:	e3a02c61 	mov	r2, #24832	; 0x6100
 4e4:	e58320cc 	str	r2, [r3, #204]	; 0xcc
	i=3200; while(i--);
}

inline static void  HOST_CMD_LOAD0(unsigned a, unsigned b, unsigned c, unsigned d)
{
	(*(volatile unsigned long *)(0x73500080+a*4))=c; 
 4e8:	e59f2190 	ldr	r2, [pc, #400]	; 680 <func_sdram_init+0x680>
 4ec:	e5832090 	str	r2, [r3, #144]	; 0x90
	(*(volatile unsigned long *)(0x735000C0+a*4))=((max(d,1)-1)<<12)|b;
 4f0:	e306201f 	movw	r2, #24607	; 0x601f
 4f4:	e58320d0 	str	r2, [r3, #208]	; 0xd0
	i=3200; while(i--);
}

inline static void  HOST_CMD_LOAD0(unsigned a, unsigned b, unsigned c, unsigned d)
{
	(*(volatile unsigned long *)(0x73500080+a*4))=c; 
 4f8:	e59f2184 	ldr	r2, [pc, #388]	; 684 <func_sdram_init+0x684>
 4fc:	e5832094 	str	r2, [r3, #148]	; 0x94
	(*(volatile unsigned long *)(0x735000C0+a*4))=((max(d,1)-1)<<12)|b;
 500:	e59f2180 	ldr	r2, [pc, #384]	; 688 <func_sdram_init+0x688>
 504:	e58320d4 	str	r2, [r3, #212]	; 0xd4
	HOST_CMD_LOAD0(4, 0x000|((ret_mr0(round_up(DDR3_tWR_ps, tCK),1,nCL)&0xFF00)>>8),((ret_mr0(round_up(DDR3_tWR_ps, tCK),1,nCL)&0x00FF)<<24)|CMD_MRS, round_up(max(DDR3_tMOD_ps, DDR3_tMOD_ck*tCK), wait_cycle));

	//ZQCL
	HOST_CMD_LOAD0(5, 0x004, CMD_ZQC, round_up(DDR3_tZQINIT_ck*tCK, wait_cycle));

	dmc0_ctl(0x12) = 0x15; // HOST_CMD_ISSUE
 508:	e3a02015 	mov	r2, #21
 50c:	e5832048 	str	r2, [r3, #72]	; 0x48
//	while(dmc0_ctl(0x12)&0x10); //

	dmc0_ctl(0x4) = 0x3; // MEM_START	
 510:	e3a02003 	mov	r2, #3
 514:	e5832010 	str	r2, [r3, #16]
	        
// bit leveling and scl
	dmc0_phy(0x53) = 0xf; // WRLVL_AUTOINC_TRIM
 518:	e3a0200f 	mov	r2, #15
 51c:	e59f30f4 	ldr	r3, [pc, #244]	; 618 <func_sdram_init+0x618>
 520:	e1a01003 	mov	r1, r3
 524:	e583214c 	str	r2, [r3, #332]	; 0x14c
	dmc0_phy(0x4D) = 1<<16; //PHY_DLL_TRIM_2
 528:	e3a02801 	mov	r2, #65536	; 0x10000
 52c:	e5832134 	str	r2, [r3, #308]	; 0x134
	dmc0_phy(0x40) = (1<<30)|(1<<28);  // SCL_START
 530:	e3a02205 	mov	r2, #1342177280	; 0x50000000
 534:	e5832100 	str	r2, [r3, #256]	; 0x100
	while(dmc0_phy(0x40)&0x10000000); // wait bit clear
 538:	e5912100 	ldr	r2, [r1, #256]	; 0x100
 53c:	e59f30d4 	ldr	r3, [pc, #212]	; 618 <func_sdram_init+0x618>
 540:	e2122201 	ands	r2, r2, #268435456	; 0x10000000
 544:	1afffffb 	bne	538 <func_sdram_init+0x538>

	// Enable gating for bit-leveling
	dmc0_phy(0x6E) = 0x0; // DISABLE_GATING_FOR_SCL
 548:	e58321b8 	str	r2, [r3, #440]	; 0x1b8
	// write in bit levelling data
	dmc0_phy(0x41) = 0xFF00FF00; // SCL_DATA_0
 54c:	e59f2138 	ldr	r2, [pc, #312]	; 68c <func_sdram_init+0x68c>
 550:	e5832104 	str	r2, [r3, #260]	; 0x104
	dmc0_phy(0x42) = 0xFF00FF00; // SCL_DATA_1
 554:	e5832108 	str	r2, [r3, #264]	; 0x108
	dmc0_phy(0x62) = 0x00080000; // PHY_SCL_START_ADDR
 558:	e3a02702 	mov	r2, #524288	; 0x80000
 55c:	e5832188 	str	r2, [r3, #392]	; 0x188
	dmc0_phy(0x40) = 0x11000000; // SCL_START
 560:	e3a02411 	mov	r2, #285212672	; 0x11000000
 564:	e5832100 	str	r2, [r3, #256]	; 0x100
	while(dmc0_phy(0x40)&0x10000000); // wait bit clear
 568:	e5932100 	ldr	r2, [r3, #256]	; 0x100
 56c:	e2121201 	ands	r1, r2, #268435456	; 0x10000000
 570:	e59f20a0 	ldr	r2, [pc, #160]	; 618 <func_sdram_init+0x618>
 574:	1afffffb 	bne	568 <func_sdram_init+0x568>

	// load SCL data into PHY
	dmc0_phy(0x62) = 0x00000000; // PHY_SCL_START_ADDR
	dmc0_phy(0x41) = 0x789b3de0; // SCL_DATA_0
 578:	e59f3110 	ldr	r3, [pc, #272]	; 690 <func_sdram_init+0x690>
	dmc0_phy(0x62) = 0x00080000; // PHY_SCL_START_ADDR
	dmc0_phy(0x40) = 0x11000000; // SCL_START
	while(dmc0_phy(0x40)&0x10000000); // wait bit clear

	// load SCL data into PHY
	dmc0_phy(0x62) = 0x00000000; // PHY_SCL_START_ADDR
 57c:	e5821188 	str	r1, [r2, #392]	; 0x188
	dmc0_phy(0x41) = 0x789b3de0; // SCL_DATA_0
 580:	e5823104 	str	r3, [r2, #260]	; 0x104
	dmc0_phy(0x42) = 0xf10e4a56; // SCL_DATA_1
 584:	e59f3108 	ldr	r3, [pc, #264]	; 694 <func_sdram_init+0x694>
 588:	e5823108 	str	r3, [r2, #264]	; 0x108

	// Run bit leveling
	dmc0_phy(0x40) = 0x30400000; //SCL_START
 58c:	e3a035c1 	mov	r3, #809500672	; 0x30400000
 590:	e5823100 	str	r3, [r2, #256]	; 0x100
	while(dmc0_phy(0x40)&0x10000000); // wait bit clear
 594:	e5921100 	ldr	r1, [r2, #256]	; 0x100
 598:	e59f3078 	ldr	r3, [pc, #120]	; 618 <func_sdram_init+0x618>
 59c:	e3110201 	tst	r1, #268435456	; 0x10000000
 5a0:	1afffffb 	bne	594 <func_sdram_init+0x594>

	// Disable gating for bit-leveling to allow proper SCL gating
	dmc0_phy(0x6E) = 0x01; // DISABLE_GATING_FOR_SCL
 5a4:	e3a02001 	mov	r2, #1
 5a8:	e58321b8 	str	r2, [r3, #440]	; 0x1b8
#if defined PREVENT_DIGITAL_DLL_FOR_RECALIBRATION
	{
	    unsigned tmp;
	    tmp = dmc0_phy(0x49);
 5ac:	e5932124 	ldr	r2, [r3, #292]	; 0x124
	    tmp |= (1<<26);
 5b0:	e3822301 	orr	r2, r2, #67108864	; 0x4000000
	    dmc0_phy(0x49) = tmp;
 5b4:	e5832124 	str	r2, [r3, #292]	; 0x124
	}
#endif
	// Write SCL data int DRAM
	dmc0_phy(0x40) = 0x11000000; // SCL_START
 5b8:	e3a02411 	mov	r2, #285212672	; 0x11000000
 5bc:	e5832100 	str	r2, [r3, #256]	; 0x100
	while(dmc0_phy(0x40)&0x10000000); // wait bit clear
 5c0:	e5932100 	ldr	r2, [r3, #256]	; 0x100
 5c4:	e3120201 	tst	r2, #268435456	; 0x10000000
 5c8:	e59f2048 	ldr	r2, [pc, #72]	; 618 <func_sdram_init+0x618>
 5cc:	1afffffb 	bne	5c0 <func_sdram_init+0x5c0>

	// Run SCL
	dmc0_phy(0x50) = 0x10; // SCL_MAIN_CLK_DELTA
 5d0:	e3a03010 	mov	r3, #16
 5d4:	e5823140 	str	r3, [r2, #320]	; 0x140
	dmc0_phy(0x40) = 0x34000000; // SCL_START
 5d8:	e3a0330d 	mov	r3, #872415232	; 0x34000000
 5dc:	e5823100 	str	r3, [r2, #256]	; 0x100
	while(dmc0_phy(0x40)&0x10000000); // wait bit clear
 5e0:	e5923100 	ldr	r3, [r2, #256]	; 0x100
 5e4:	e3130201 	tst	r3, #268435456	; 0x10000000
 5e8:	1afffffc 	bne	5e0 <func_sdram_init+0x5e0>
	// Turn off x-prop fix in simulation
	dmc0_phy(0x6E) = 0x03; // DISABLE_GATING_FOR_SCL
 5ec:	e59f3024 	ldr	r3, [pc, #36]	; 618 <func_sdram_init+0x618>
 5f0:	e3a02003 	mov	r2, #3
 5f4:	e58321b8 	str	r2, [r3, #440]	; 0x1b8
	ddr_clock_set();
 	sdram_init(1);
#else
	#error "not selected ddr type.."
#endif
}
 5f8:	e28dd00c 	add	sp, sp, #12
 5fc:	e8bd8030 	pop	{r4, r5, pc}
 600:	00200014 	.word	0x00200014
 604:	74400000 	.word	0x74400000
 608:	04021681 	.word	0x04021681
 60c:	0601e90c 	.word	0x0601e90c
 610:	04034403 	.word	0x04034403
 614:	00200012 	.word	0x00200012
 618:	73880000 	.word	0x73880000
 61c:	50ff40f4 	.word	0x50ff40f4
 620:	a0001000 	.word	0xa0001000
 624:	01000075 	.word	0x01000075
 628:	02000501 	.word	0x02000501
 62c:	02200020 	.word	0x02200020
 630:	000251c0 	.word	0x000251c0
 634:	00c60046 	.word	0x00c60046
 638:	a0001004 	.word	0xa0001004
 63c:	73500000 	.word	0x73500000
 640:	00190a0d 	.word	0x00190a0d
 644:	000a03f8 	.word	0x000a03f8
 648:	000113f0 	.word	0x000113f0
 64c:	18780e35 	.word	0x18780e35
 650:	d62131ab 	.word	0xd62131ab
 654:	0022fe03 	.word	0x0022fe03
 658:	a662e307 	.word	0xa662e307
 65c:	7f10160f 	.word	0x7f10160f
 660:	ff000002 	.word	0xff000002
 664:	00030002 	.word	0x00030002
 668:	00030001 	.word	0x00030001
 66c:	00251100 	.word	0x00251100
 670:	73020002 	.word	0x73020002
 674:	20fff001 	.word	0x20fff001
 678:	00fff001 	.word	0x00fff001
 67c:	46fff001 	.word	0x46fff001
 680:	14fff001 	.word	0x14fff001
 684:	00fff601 	.word	0x00fff601
 688:	000ff004 	.word	0x000ff004
 68c:	ff00ff00 	.word	0xff00ff00
 690:	789b3de0 	.word	0x789b3de0
 694:	f10e4a56 	.word	0xf10e4a56

Disassembly of section .text.ddr_self_refresh_exit:

00000000 <ddr_self_refresh_exit>:
{
	volatile int i;
	unsigned dat;
//------------------------------------------------------------------------------------------------
// exit self-refresh mode
	dmc0_ctl(0xB) = (dmc0_ctl(0xB) & ~(1<<3));
   0:	e59f308c 	ldr	r3, [pc, #140]	; 94 <ddr_self_refresh_exit+0x94>
	    dmc0_ctl(0x48) &= (~0x10000000);
	}
}

void ddr_self_refresh_exit(void)
{
   4:	e24dd008 	sub	sp, sp, #8
	volatile int i;
	unsigned dat;
//------------------------------------------------------------------------------------------------
// exit self-refresh mode
	dmc0_ctl(0xB) = (dmc0_ctl(0xB) & ~(1<<3));
   8:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
   c:	e3c22008 	bic	r2, r2, #8
  10:	e583202c 	str	r2, [r3, #44]	; 0x2c
//------------------------------------------------------------------------------------------------
// TRIM

	// Disable gating for bit-leveling to allow proper SCL gating
	dmc0_phy(0x6E) = 0x1; // DISABLE_GATING_FOR_SCL
  14:	e283370e 	add	r3, r3, #3670016	; 0x380000
  18:	e3a02001 	mov	r2, #1
  1c:	e1a01003 	mov	r1, r3
  20:	e58321b8 	str	r2, [r3, #440]	; 0x1b8
	// Write SCL data int DRAM
	dmc0_phy(0x40) = 0x11000000; // SCL_START
  24:	e3a02411 	mov	r2, #285212672	; 0x11000000
  28:	e5832100 	str	r2, [r3, #256]	; 0x100
	while(dmc0_phy(0x40)&0x10000000); // wait bit clear
  2c:	e5912100 	ldr	r2, [r1, #256]	; 0x100
  30:	e59f3060 	ldr	r3, [pc, #96]	; 98 <ddr_self_refresh_exit+0x98>
  34:	e3120201 	tst	r2, #268435456	; 0x10000000
  38:	1afffffb 	bne	2c <ddr_self_refresh_exit+0x2c>

	// Run SCL
	dmc0_phy(0x50) = 0x10; // SCL_MAIN_CLK_DELTA
  3c:	e3a02010 	mov	r2, #16
  40:	e5832140 	str	r2, [r3, #320]	; 0x140
	dmc0_phy(0x40) = 0x34000000; // SCL_START
  44:	e3a0230d 	mov	r2, #872415232	; 0x34000000
  48:	e5832100 	str	r2, [r3, #256]	; 0x100
	while(dmc0_phy(0x40)&0x10000000); // wait bit clear
  4c:	e5931100 	ldr	r1, [r3, #256]	; 0x100
  50:	e59f2040 	ldr	r2, [pc, #64]	; 98 <ddr_self_refresh_exit+0x98>
  54:	e2111201 	ands	r1, r1, #268435456	; 0x10000000
  58:	1afffffb 	bne	4c <ddr_self_refresh_exit+0x4c>

	dat = dmc0_phy(0x40);
  5c:	e5923100 	ldr	r3, [r2, #256]	; 0x100
	dat = dat & 0xf;
	// Turn off x-prop fix in simulation
	dmc0_phy(0x6E) = 0x03; // DISABLE_GATING_FOR_SCL	
  60:	e3a03003 	mov	r3, #3
  64:	e58231b8 	str	r3, [r2, #440]	; 0x1b8
//------------------------------------------------------------------------------------------------
// resume dram traffic
	HALT_CFG0 = 0x0;
  68:	e59f302c 	ldr	r3, [pc, #44]	; 9c <ddr_self_refresh_exit+0x9c>
  6c:	e583101c 	str	r1, [r3, #28]
	i=3200; while(i--);
  70:	e3a03d32 	mov	r3, #3200	; 0xc80
  74:	e58d3004 	str	r3, [sp, #4]
  78:	e59d3004 	ldr	r3, [sp, #4]
  7c:	e3530000 	cmp	r3, #0
  80:	e2432001 	sub	r2, r3, #1
  84:	e58d2004 	str	r2, [sp, #4]
  88:	1afffffa 	bne	78 <ddr_self_refresh_exit+0x78>
}
  8c:	e28dd008 	add	sp, sp, #8
  90:	e12fff1e 	bx	lr
  94:	73500000 	.word	0x73500000
  98:	73880000 	.word	0x73880000
  9c:	73820000 	.word	0x73820000

Disassembly of section .text._change_mem_clock:

00000000 <_change_mem_clock>:
	volatile int i;
	unsigned master_dll, mas_dll_dly, dat;
//------------------------------------------------------------------------------------------------
// hold dram traffic

	HALT_CFG0 = 0x1;
   0:	e59f33e0 	ldr	r3, [pc, #992]	; 3e8 <_change_mem_clock+0x3e8>

/*===========================================================================
FUNCTION
===========================================================================*/
void _change_mem_clock(void)
{
   4:	e24dd008 	sub	sp, sp, #8
	volatile int i;
	unsigned master_dll, mas_dll_dly, dat;
//------------------------------------------------------------------------------------------------
// hold dram traffic

	HALT_CFG0 = 0x1;
   8:	e3a02001 	mov	r2, #1
   c:	e583201c 	str	r2, [r3, #28]
	while((HALT_STS0&0xC00) != 0xC00);
  10:	e593200c 	ldr	r2, [r3, #12]
  14:	e2022b03 	and	r2, r2, #3072	; 0xc00
  18:	e3520b03 	cmp	r2, #3072	; 0xc00
  1c:	1afffffb 	bne	10 <_change_mem_clock+0x10>
	i=3200; while(i--);
  20:	e3a03d32 	mov	r3, #3200	; 0xc80
  24:	e58d3004 	str	r3, [sp, #4]
  28:	e59d3004 	ldr	r3, [sp, #4]
  2c:	e3530000 	cmp	r3, #0
  30:	e2432001 	sub	r2, r3, #1
  34:	e58d2004 	str	r2, [sp, #4]
  38:	1afffffa 	bne	28 <_change_mem_clock+0x28>

//------------------------------------------------------------------------------------------------
// enter self-refresh mode

	dmc0_ctl(0xB) = (dmc0_ctl(0xB) & ~((1<<3)|(0x3FF<<12)));
  3c:	e59f33a8 	ldr	r3, [pc, #936]	; 3ec <_change_mem_clock+0x3ec>
  40:	e59f23a8 	ldr	r2, [pc, #936]	; 3f0 <_change_mem_clock+0x3f0>
  44:	e593102c 	ldr	r1, [r3, #44]	; 0x2c
  48:	e0012002 	and	r2, r1, r2
  4c:	e583202c 	str	r2, [r3, #44]	; 0x2c
	dmc0_ctl(0xB) = dmc0_ctl(0xB) | ((1<<3)|(0x8<<12));
  50:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
  54:	e3822902 	orr	r2, r2, #32768	; 0x8000
  58:	e3822008 	orr	r2, r2, #8
  5c:	e583202c 	str	r2, [r3, #44]	; 0x2c
	i=3200; while(i--);
  60:	e3a03d32 	mov	r3, #3200	; 0xc80
  64:	e58d3004 	str	r3, [sp, #4]
  68:	e59d3004 	ldr	r3, [sp, #4]
  6c:	e3530000 	cmp	r3, #0
  70:	e2432001 	sub	r2, r3, #1
  74:	e58d2004 	str	r2, [sp, #4]
  78:	1afffffa 	bne	68 <_change_mem_clock+0x68>
//------------------------------------------------------------------------------------------------
// clock change
	// :TODO
#if 1
	*(volatile unsigned long *)addr_clk(0x000008) = 0x00001F00; //CKC_CHANGE_ARG(CKC_CTRL_VALUE);  // mem bus
  7c:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
  80:	e3a02c1f 	mov	r2, #7936	; 0x1f00
  84:	e5832008 	str	r2, [r3, #8]
	while((*(volatile unsigned long *)addr_clk(0x000008))&(1<<29)); // CFGREQ
  88:	e5932008 	ldr	r2, [r3, #8]
  8c:	e3120202 	tst	r2, #536870912	; 0x20000000
  90:	1afffffc 	bne	88 <_change_mem_clock+0x88>
	i=100; while(i--);
  94:	e3a03064 	mov	r3, #100	; 0x64
  98:	e58d3004 	str	r3, [sp, #4]
  9c:	e59d3004 	ldr	r3, [sp, #4]
  a0:	e3530000 	cmp	r3, #0
  a4:	e2432001 	sub	r2, r3, #1
  a8:	e58d2004 	str	r2, [sp, #4]
  ac:	1afffffa 	bne	9c <_change_mem_clock+0x9c>
	*(volatile unsigned long *)addr_clk(0x000050) =  CKC_CHANGE_ARG(PLL_VALUE) | 0x00100000; //pll1 for mem , lock_en
  b0:	e59f333c 	ldr	r3, [pc, #828]	; 3f4 <_change_mem_clock+0x3f4>
  b4:	e5932000 	ldr	r2, [r3]
  b8:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
  bc:	e3822601 	orr	r2, r2, #1048576	; 0x100000
  c0:	e5832050 	str	r2, [r3, #80]	; 0x50
	*(volatile unsigned long *)addr_clk(0x000050) |= 0x80000000; //pll1 for mem , lock_en
  c4:	e5932050 	ldr	r2, [r3, #80]	; 0x50
  c8:	e3822102 	orr	r2, r2, #-2147483648	; 0x80000000
  cc:	e5832050 	str	r2, [r3, #80]	; 0x50
	i=20; while(i--)while((*(volatile unsigned long *)addr_clk(0x000050) & 0x00800000) == 0);
  d0:	e3a02014 	mov	r2, #20
  d4:	e58d2004 	str	r2, [sp, #4]
  d8:	e59d2004 	ldr	r2, [sp, #4]
  dc:	e3520000 	cmp	r2, #0
  e0:	e2421001 	sub	r1, r2, #1
  e4:	e58d1004 	str	r1, [sp, #4]
  e8:	0a000003 	beq	fc <_change_mem_clock+0xfc>
  ec:	e5932050 	ldr	r2, [r3, #80]	; 0x50
  f0:	e3120502 	tst	r2, #8388608	; 0x800000
  f4:	0afffffc 	beq	ec <_change_mem_clock+0xec>
  f8:	eafffff6 	b	d8 <_change_mem_clock+0xd8>
	*(volatile unsigned long *)addr_clk(0x000008) = 0x00001F01;  // mem bus
  fc:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
 100:	e3012f01 	movw	r2, #7937	; 0x1f01
 104:	e5832008 	str	r2, [r3, #8]
	while((*(volatile unsigned long *)addr_clk(0x000008))&(1<<29)); // CFGREQ
 108:	e5932008 	ldr	r2, [r3, #8]
 10c:	e3120202 	tst	r2, #536870912	; 0x20000000
 110:	1afffffc 	bne	108 <_change_mem_clock+0x108>
	i=10000; while(i--);
 114:	e3023710 	movw	r3, #10000	; 0x2710
 118:	e58d3004 	str	r3, [sp, #4]
 11c:	e59d3004 	ldr	r3, [sp, #4]
 120:	e3530000 	cmp	r3, #0
 124:	e2432001 	sub	r2, r3, #1
 128:	e58d2004 	str	r2, [sp, #4]
 12c:	1afffffa 	bne	11c <_change_mem_clock+0x11c>
#endif
//------------------------------------------------------------------------------------------------
// re-initailize
	dmc0_phy(0x46) = CKC_CHANGE_ARG(DMC_46H);
 130:	e59f32bc 	ldr	r3, [pc, #700]	; 3f4 <_change_mem_clock+0x3f4>
 134:	e59f22bc 	ldr	r2, [pc, #700]	; 3f8 <_change_mem_clock+0x3f8>
 138:	e5931054 	ldr	r1, [r3, #84]	; 0x54
 13c:	e5821118 	str	r1, [r2, #280]	; 0x118
	dmc0_phy(0x47) = CKC_CHANGE_ARG(DMC_47H);
 140:	e5931058 	ldr	r1, [r3, #88]	; 0x58
 144:	e582111c 	str	r1, [r2, #284]	; 0x11c
	dmc0_phy(0x6f) = CKC_CHANGE_ARG(DMC_6FH);
 148:	e5931060 	ldr	r1, [r3, #96]	; 0x60
 14c:	e58211bc 	str	r1, [r2, #444]	; 0x1bc
	dmc0_phy(0x54) = CKC_CHANGE_ARG(DMC_54H);
 150:	e593105c 	ldr	r1, [r3, #92]	; 0x5c
 154:	e5821150 	str	r1, [r2, #336]	; 0x150

	dmc0_ctl(0xa) = CKC_CHANGE_ARG(DMC_AH);   // timing
 158:	e242270e 	sub	r2, r2, #3670016	; 0x380000
 15c:	e593100c 	ldr	r1, [r3, #12]
 160:	e5821028 	str	r1, [r2, #40]	; 0x28
	dmc0_ctl(0xc) = CKC_CHANGE_ARG(DMC_CH);
 164:	e5931010 	ldr	r1, [r3, #16]
 168:	e5821030 	str	r1, [r2, #48]	; 0x30
	dmc0_ctl(0xd) = CKC_CHANGE_ARG(DMC_DH);
 16c:	e5931014 	ldr	r1, [r3, #20]
 170:	e5821034 	str	r1, [r2, #52]	; 0x34
	dmc0_ctl(0xe) = CKC_CHANGE_ARG(DMC_EH);
 174:	e5931018 	ldr	r1, [r3, #24]
 178:	e5821038 	str	r1, [r2, #56]	; 0x38
	dmc0_ctl(0xf) = CKC_CHANGE_ARG(DMC_FH);
 17c:	e593101c 	ldr	r1, [r3, #28]
 180:	e582103c 	str	r1, [r2, #60]	; 0x3c

	dmc0_ctl(0x15) = CKC_CHANGE_ARG(DMC_15H);
 184:	e5933028 	ldr	r3, [r3, #40]	; 0x28
 188:	e5823054 	str	r3, [r2, #84]	; 0x54

	dmc0_ctl(0x16) = (0<<16)|2;
 18c:	e3a03002 	mov	r3, #2
 190:	e5823058 	str	r3, [r2, #88]	; 0x58
	i=3200; while(i--);
 194:	e3a03d32 	mov	r3, #3200	; 0xc80
 198:	e58d3004 	str	r3, [sp, #4]
 19c:	e1a03002 	mov	r3, r2
 1a0:	e59d2004 	ldr	r2, [sp, #4]
 1a4:	e3520000 	cmp	r2, #0
 1a8:	e2421001 	sub	r1, r2, #1
 1ac:	e58d1004 	str	r1, [sp, #4]
 1b0:	1afffffa 	bne	1a0 <_change_mem_clock+0x1a0>
	// AUTO_SCL_CTRL
	#if 1 // temporary prevent
	dmc0_ctl(0x10) = 0*MEM_CHIP_SELECTS; // ODT_CONFIG
 1b4:	e5832040 	str	r2, [r3, #64]	; 0x40
	dmc0_ctl(0x13) = (1<<16)|2;			 // ODT_EN_CONFIG
 1b8:	e59f223c 	ldr	r2, [pc, #572]	; 3fc <_change_mem_clock+0x3fc>
 1bc:	e583204c 	str	r2, [r3, #76]	; 0x4c
	dmc0_ctl(0x10) = 1*MEM_CHIP_SELECTS; // ODT_CONFIG
 1c0:	e3a02002 	mov	r2, #2
 1c4:	e5832040 	str	r2, [r3, #64]	; 0x40
	dmc0_ctl(0x13) = (2<<16)|1;			 // ODT_EN_CONFIG	
 1c8:	e59f2230 	ldr	r2, [pc, #560]	; 400 <_change_mem_clock+0x400>
 1cc:	e583204c 	str	r2, [r3, #76]	; 0x4c

	dmc0_ctl(0x10) = CKC_CHANGE_ARG(DMC_10H);
 1d0:	e59f221c 	ldr	r2, [pc, #540]	; 3f4 <_change_mem_clock+0x3f4>
 1d4:	e5921020 	ldr	r1, [r2, #32]
 1d8:	e5831040 	str	r1, [r3, #64]	; 0x40
	dmc0_ctl(0x11) = CKC_CHANGE_ARG(DMC_11H);
 1dc:	e5921024 	ldr	r1, [r2, #36]	; 0x24
 1e0:	e5831044 	str	r1, [r3, #68]	; 0x44
#endif

//------------------------------------------------------------------------------------------------
// exit self-refresh mode
	dmc0_ctl(0xB) = (dmc0_ctl(0xB) & ~(1<<3));
 1e4:	e593102c 	ldr	r1, [r3, #44]	; 0x2c
 1e8:	e3c11008 	bic	r1, r1, #8
 1ec:	e583102c 	str	r1, [r3, #44]	; 0x2c
	i=3200; while(i--);
 1f0:	e3a03d32 	mov	r3, #3200	; 0xc80
 1f4:	e58d3004 	str	r3, [sp, #4]
 1f8:	e59d3004 	ldr	r3, [sp, #4]
 1fc:	e3530000 	cmp	r3, #0
 200:	e2431001 	sub	r1, r3, #1
 204:	e58d1004 	str	r1, [sp, #4]
 208:	1afffffa 	bne	1f8 <_change_mem_clock+0x1f8>

//------------------------------------------------------------------------------------------------
// MR setting and TRIM
	dmc0_ctl(0x20) = CKC_CHANGE_ARG(DMC_20H);
 20c:	e592102c 	ldr	r1, [r2, #44]	; 0x2c
 210:	e59f31d4 	ldr	r3, [pc, #468]	; 3ec <_change_mem_clock+0x3ec>
 214:	e5831080 	str	r1, [r3, #128]	; 0x80
	dmc0_ctl(0x30) = CKC_CHANGE_ARG(DMC_30H);
 218:	e5921040 	ldr	r1, [r2, #64]	; 0x40
 21c:	e58310c0 	str	r1, [r3, #192]	; 0xc0
	dmc0_ctl(0x21) = CKC_CHANGE_ARG(DMC_21H);
 220:	e5921030 	ldr	r1, [r2, #48]	; 0x30
 224:	e5831084 	str	r1, [r3, #132]	; 0x84
	dmc0_ctl(0x31) = CKC_CHANGE_ARG(DMC_31H);
 228:	e5921044 	ldr	r1, [r2, #68]	; 0x44
 22c:	e58310c4 	str	r1, [r3, #196]	; 0xc4
	dmc0_ctl(0x22) = CKC_CHANGE_ARG(DMC_22H);
 230:	e5921034 	ldr	r1, [r2, #52]	; 0x34
 234:	e5831088 	str	r1, [r3, #136]	; 0x88
	dmc0_ctl(0x32) = CKC_CHANGE_ARG(DMC_32H);
 238:	e5922048 	ldr	r2, [r2, #72]	; 0x48
 23c:	e58320c8 	str	r2, [r3, #200]	; 0xc8

	dmc0_ctl(0x12) = 0x12; // HOST_CMD_ISSUE
 240:	e3a02012 	mov	r2, #18
 244:	e5832048 	str	r2, [r3, #72]	; 0x48
//	while((dmc0_ctl(0x12)&0x10));  // temporary prevent

	dat = dmc0_phy(0x49);
 248:	e283370e 	add	r3, r3, #3670016	; 0x380000
 24c:	e1a01003 	mov	r1, r3
 250:	e5932124 	ldr	r2, [r3, #292]	; 0x124
	dat = (dat>>8) & 0x3FFFF;
	i=3200; while(i--);
 254:	e3a02d32 	mov	r2, #3200	; 0xc80
 258:	e58d2004 	str	r2, [sp, #4]
 25c:	e59d3004 	ldr	r3, [sp, #4]
 260:	e3530000 	cmp	r3, #0
 264:	e2432001 	sub	r2, r3, #1
 268:	e58d2004 	str	r2, [sp, #4]
 26c:	1afffffa 	bne	25c <_change_mem_clock+0x25c>
	mas_dll_dly = 0;
	master_dll = (10<<28)|0x1000;

	while(mas_dll_dly==0)
	{
		mas_dll_dly = dmc0_phy(0x4A);
 270:	e5912128 	ldr	r2, [r1, #296]	; 0x128
 274:	e59f317c 	ldr	r3, [pc, #380]	; 3f8 <_change_mem_clock+0x3f8>
	i=3200; while(i--);

	mas_dll_dly = 0;
	master_dll = (10<<28)|0x1000;

	while(mas_dll_dly==0)
 278:	e1b02c22 	lsrs	r2, r2, #24
 27c:	0afffffb 	beq	270 <_change_mem_clock+0x270>
	{
		mas_dll_dly = dmc0_phy(0x4A);
		mas_dll_dly = mas_dll_dly  >> 24;
	}

	mas_dll_dly = dmc0_phy(0x4A);
 280:	e5932128 	ldr	r2, [r3, #296]	; 0x128

	mas_dll_dly = (mas_dll_dly >> 24) >> 1;
 284:	e1a02ca2 	lsr	r2, r2, #25
	dmc0_phy(0x4A) = 0x200|mas_dll_dly;
 288:	e3821c02 	orr	r1, r2, #512	; 0x200
 28c:	e5831128 	str	r1, [r3, #296]	; 0x128
	dmc0_phy(0x49) = master_dll | mas_dll_dly | (1<<27);
 290:	e382132a 	orr	r1, r2, #-1476395008	; 0xa8000000
	dmc0_phy(0x69) = (1<<SLV_DLY_WIDTH)|mas_dll_dly;
 294:	e3822040 	orr	r2, r2, #64	; 0x40

	mas_dll_dly = dmc0_phy(0x4A);

	mas_dll_dly = (mas_dll_dly >> 24) >> 1;
	dmc0_phy(0x4A) = 0x200|mas_dll_dly;
	dmc0_phy(0x49) = master_dll | mas_dll_dly | (1<<27);
 298:	e3811a01 	orr	r1, r1, #4096	; 0x1000
 29c:	e5831124 	str	r1, [r3, #292]	; 0x124
	dmc0_phy(0x69) = (1<<SLV_DLY_WIDTH)|mas_dll_dly;
 2a0:	e58321a4 	str	r2, [r3, #420]	; 0x1a4

	#if defined(BIT_LEVELING_CLOCK_CHANGE) // temporary prevent
	dmc0_phy(0x53) = 0xf;
 2a4:	e3a0200f 	mov	r2, #15
 2a8:	e583214c 	str	r2, [r3, #332]	; 0x14c
	dmc0_phy(0x4D) = 1<<16;
 2ac:	e3a02801 	mov	r2, #65536	; 0x10000
 2b0:	e5832134 	str	r2, [r3, #308]	; 0x134
	dmc0_phy(0x40) = (1<<30)|(1<<28); // SCL_START
 2b4:	e3a02205 	mov	r2, #1342177280	; 0x50000000
 2b8:	e5832100 	str	r2, [r3, #256]	; 0x100
	while((dmc0_ctl(0x12)&0x10));
 2bc:	e59f2128 	ldr	r2, [pc, #296]	; 3ec <_change_mem_clock+0x3ec>
 2c0:	e5923048 	ldr	r3, [r2, #72]	; 0x48
 2c4:	e3130010 	tst	r3, #16
 2c8:	1afffffc 	bne	2c0 <_change_mem_clock+0x2c0>
	while((dmc0_phy(0x40)&0x10000000));
 2cc:	e59f2124 	ldr	r2, [pc, #292]	; 3f8 <_change_mem_clock+0x3f8>
 2d0:	e5923100 	ldr	r3, [r2, #256]	; 0x100
 2d4:	e3130201 	tst	r3, #268435456	; 0x10000000
 2d8:	1afffffc 	bne	2d0 <_change_mem_clock+0x2d0>
	#endif
	dat = dmc0_phy(0x52);
 2dc:	e59f3114 	ldr	r3, [pc, #276]	; 3f8 <_change_mem_clock+0x3f8>
 2e0:	e5933148 	ldr	r3, [r3, #328]	; 0x148
	dat = dat & 0xf;

	i=3200; while(i--);
 2e4:	e3a03d32 	mov	r3, #3200	; 0xc80
 2e8:	e58d3004 	str	r3, [sp, #4]
 2ec:	e59d2004 	ldr	r2, [sp, #4]
 2f0:	e3520000 	cmp	r2, #0
 2f4:	e2423001 	sub	r3, r2, #1
 2f8:	e58d3004 	str	r3, [sp, #4]
 2fc:	1afffffa 	bne	2ec <_change_mem_clock+0x2ec>
	#if defined(BIT_LEVELING_CLOCK_CHANGE) // temporary prevent
	// Enable gating for bit-leveling
	dmc0_phy(0x6E) = 0x0; // DISABLE_GATING_FOR_SCL
 300:	e59f30f0 	ldr	r3, [pc, #240]	; 3f8 <_change_mem_clock+0x3f8>
 304:	e58321b8 	str	r2, [r3, #440]	; 0x1b8
	// write in bit levelling data
	dmc0_phy(0x41) = 0xFF00FF00; // SCL_DATA_0
 308:	e59f20f4 	ldr	r2, [pc, #244]	; 404 <_change_mem_clock+0x404>
 30c:	e5832104 	str	r2, [r3, #260]	; 0x104
	dmc0_phy(0x42) = 0xFF00FF00; // SCL_DATA_1
 310:	e5832108 	str	r2, [r3, #264]	; 0x108
	dmc0_phy(0x62) = 0x00080000; // PHY_SCL_START_ADDR
 314:	e3a02702 	mov	r2, #524288	; 0x80000
 318:	e5832188 	str	r2, [r3, #392]	; 0x188
	dmc0_phy(0x40) = 0x11000000; // SCL_START
 31c:	e3a02411 	mov	r2, #285212672	; 0x11000000
 320:	e5832100 	str	r2, [r3, #256]	; 0x100
	while(dmc0_phy(0x40)&0x10000000); // wait bit clear
 324:	e5931100 	ldr	r1, [r3, #256]	; 0x100
 328:	e59f20c8 	ldr	r2, [pc, #200]	; 3f8 <_change_mem_clock+0x3f8>
 32c:	e2111201 	ands	r1, r1, #268435456	; 0x10000000
 330:	1afffffb 	bne	324 <_change_mem_clock+0x324>

	// load SCL data into PHY
	dmc0_phy(0x62) = 0x00000000; // PHY_SCL_START_ADDR
	dmc0_phy(0x41) = 0x789b3de0; // SCL_DATA_0
 334:	e59f30cc 	ldr	r3, [pc, #204]	; 408 <_change_mem_clock+0x408>
	dmc0_phy(0x62) = 0x00080000; // PHY_SCL_START_ADDR
	dmc0_phy(0x40) = 0x11000000; // SCL_START
	while(dmc0_phy(0x40)&0x10000000); // wait bit clear

	// load SCL data into PHY
	dmc0_phy(0x62) = 0x00000000; // PHY_SCL_START_ADDR
 338:	e5821188 	str	r1, [r2, #392]	; 0x188
	dmc0_phy(0x41) = 0x789b3de0; // SCL_DATA_0
 33c:	e5823104 	str	r3, [r2, #260]	; 0x104
	dmc0_phy(0x42) = 0xf10e4a56; // SCL_DATA_1
 340:	e59f30c4 	ldr	r3, [pc, #196]	; 40c <_change_mem_clock+0x40c>
 344:	e5823108 	str	r3, [r2, #264]	; 0x108
	dmc0_phy(0x40) = 0x30400000; // SCL_START
 348:	e3a035c1 	mov	r3, #809500672	; 0x30400000
 34c:	e5823100 	str	r3, [r2, #256]	; 0x100
	while(dmc0_phy(0x40)&0x10000000); // wait bit clear
 350:	e5921100 	ldr	r1, [r2, #256]	; 0x100
 354:	e59f309c 	ldr	r3, [pc, #156]	; 3f8 <_change_mem_clock+0x3f8>
 358:	e3110201 	tst	r1, #268435456	; 0x10000000
 35c:	1afffffb 	bne	350 <_change_mem_clock+0x350>


	dat = dmc0_phy(0x6B);
 360:	e59321ac 	ldr	r2, [r3, #428]	; 0x1ac
	#endif	

	// Disable gating for bit-leveling to allow proper SCL gating
	dmc0_phy(0x6E) = 0x1; // DISABLE_GATING_FOR_SCL
 364:	e3a02001 	mov	r2, #1
 368:	e58321b8 	str	r2, [r3, #440]	; 0x1b8
#if defined PREVENT_DIGITAL_DLL_FOR_RECALIBRATION
	{
	    unsigned tmp;
	    tmp = dmc0_phy(0x49);
 36c:	e5932124 	ldr	r2, [r3, #292]	; 0x124
	    tmp |= (1<<26);
 370:	e3822301 	orr	r2, r2, #67108864	; 0x4000000
	    dmc0_phy(0x49) = tmp;
 374:	e5832124 	str	r2, [r3, #292]	; 0x124
	}
#endif
	// Write SCL data int DRAM
	dmc0_phy(0x40) = 0x11000000; // SCL_START
 378:	e3a02411 	mov	r2, #285212672	; 0x11000000
 37c:	e5832100 	str	r2, [r3, #256]	; 0x100
	while(dmc0_phy(0x40)&0x10000000); // wait bit clear
 380:	e5932100 	ldr	r2, [r3, #256]	; 0x100
 384:	e3120201 	tst	r2, #268435456	; 0x10000000
 388:	e59f2068 	ldr	r2, [pc, #104]	; 3f8 <_change_mem_clock+0x3f8>
 38c:	1afffffb 	bne	380 <_change_mem_clock+0x380>

	// Run SCL
	dmc0_phy(0x50) = 0x10; // SCL_MAIN_CLK_DELTA
 390:	e3a03010 	mov	r3, #16
 394:	e5823140 	str	r3, [r2, #320]	; 0x140
	dmc0_phy(0x40) = 0x34000000; // SCL_START
 398:	e3a0330d 	mov	r3, #872415232	; 0x34000000
 39c:	e5823100 	str	r3, [r2, #256]	; 0x100
	while(dmc0_phy(0x40)&0x10000000); // wait bit clear
 3a0:	e5921100 	ldr	r1, [r2, #256]	; 0x100
 3a4:	e59f304c 	ldr	r3, [pc, #76]	; 3f8 <_change_mem_clock+0x3f8>
 3a8:	e2111201 	ands	r1, r1, #268435456	; 0x10000000
 3ac:	1afffffb 	bne	3a0 <_change_mem_clock+0x3a0>

	dat = dmc0_phy(0x40);
 3b0:	e5932100 	ldr	r2, [r3, #256]	; 0x100
	dat = dat & 0xf;
	// Turn off x-prop fix in simulation
	dmc0_phy(0x6E) = 0x03; // DISABLE_GATING_FOR_SCL
 3b4:	e3a02003 	mov	r2, #3
 3b8:	e58321b8 	str	r2, [r3, #440]	; 0x1b8
	dmc0_phy(0x67) = 0x0200002F;
#endif

//------------------------------------------------------------------------------------------------
// resume dram traffic
	HALT_CFG0 = 0x0;
 3bc:	e2433806 	sub	r3, r3, #393216	; 0x60000
 3c0:	e583101c 	str	r1, [r3, #28]
	i=3200; while(i--);
 3c4:	e3a03d32 	mov	r3, #3200	; 0xc80
 3c8:	e58d3004 	str	r3, [sp, #4]
 3cc:	e59d3004 	ldr	r3, [sp, #4]
 3d0:	e3530000 	cmp	r3, #0
 3d4:	e2432001 	sub	r2, r3, #1
 3d8:	e58d2004 	str	r2, [sp, #4]
 3dc:	1afffffa 	bne	3cc <_change_mem_clock+0x3cc>
#endif	
}
 3e0:	e28dd008 	add	sp, sp, #8
 3e4:	e12fff1e 	bx	lr
 3e8:	73820000 	.word	0x73820000
 3ec:	73500000 	.word	0x73500000
 3f0:	ffc00ff7 	.word	0xffc00ff7
 3f4:	10004000 	.word	0x10004000
 3f8:	73880000 	.word	0x73880000
 3fc:	00010002 	.word	0x00010002
 400:	00020001 	.word	0x00020001
 404:	ff00ff00 	.word	0xff00ff00
 408:	789b3de0 	.word	0x789b3de0
 40c:	f10e4a56 	.word	0xf10e4a56

Disassembly of section .text.ddr_self_refresh_enter:

00000000 <ddr_self_refresh_enter>:
{
	volatile unsigned i;

//------------------------------------------------------------------------------------------------
// hold dram traffic
	HALT_CFG0 = 0x1;
   0:	e59f30bc 	ldr	r3, [pc, #188]	; c4 <ddr_self_refresh_enter+0xc4>
	#error "not selected ddr type.."
#endif
}

void ddr_self_refresh_enter(unsigned int shutdown)
{
   4:	e24dd008 	sub	sp, sp, #8
	volatile unsigned i;

//------------------------------------------------------------------------------------------------
// hold dram traffic
	HALT_CFG0 = 0x1;
   8:	e3a02001 	mov	r2, #1
   c:	e583201c 	str	r2, [r3, #28]
	while((HALT_STS0&0xC00) != 0xC00);
  10:	e593200c 	ldr	r2, [r3, #12]
  14:	e2022b03 	and	r2, r2, #3072	; 0xc00
  18:	e3520b03 	cmp	r2, #3072	; 0xc00
  1c:	1afffffb 	bne	10 <ddr_self_refresh_enter+0x10>
	i=3200; while(i--);
  20:	e3a03d32 	mov	r3, #3200	; 0xc80
  24:	e58d3004 	str	r3, [sp, #4]
  28:	e59d3004 	ldr	r3, [sp, #4]
  2c:	e3530000 	cmp	r3, #0
  30:	e2432001 	sub	r2, r3, #1
  34:	e58d2004 	str	r2, [sp, #4]
  38:	1afffffa 	bne	28 <ddr_self_refresh_enter+0x28>
//------------------------------------------------------------------------------------------------
// enter self-refresh mode

	dmc0_ctl(0xB) = (dmc0_ctl(0xB) & ~((1<<3)|(0x3FF<<12)));
  3c:	e59f3084 	ldr	r3, [pc, #132]	; c8 <ddr_self_refresh_enter+0xc8>
  40:	e59f2084 	ldr	r2, [pc, #132]	; cc <ddr_self_refresh_enter+0xcc>
  44:	e593102c 	ldr	r1, [r3, #44]	; 0x2c
  48:	e0012002 	and	r2, r1, r2
  4c:	e583202c 	str	r2, [r3, #44]	; 0x2c
	dmc0_ctl(0xB) = dmc0_ctl(0xB) | ((1<<3)|(1<<12));
  50:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
  54:	e3822a01 	orr	r2, r2, #4096	; 0x1000
  58:	e3822008 	orr	r2, r2, #8
  5c:	e583202c 	str	r2, [r3, #44]	; 0x2c
	i=3200; while(i--);
  60:	e3a02d32 	mov	r2, #3200	; 0xc80
  64:	e58d2004 	str	r2, [sp, #4]
  68:	e59d2004 	ldr	r2, [sp, #4]
  6c:	e3520000 	cmp	r2, #0
  70:	e2421001 	sub	r1, r2, #1
  74:	e58d1004 	str	r1, [sp, #4]
  78:	1afffffa 	bne	68 <ddr_self_refresh_enter+0x68>

	if(shutdown){
  7c:	e3500000 	cmp	r0, #0
  80:	0a00000d 	beq	bc <ddr_self_refresh_enter+0xbc>
	    dmc0_ctl(0x5C) &= (~0x1);
  84:	e5932170 	ldr	r2, [r3, #368]	; 0x170
  88:	e3c22001 	bic	r2, r2, #1
  8c:	e5832170 	str	r2, [r3, #368]	; 0x170
	    i=320000; while(i--);
  90:	e59f3038 	ldr	r3, [pc, #56]	; d0 <ddr_self_refresh_enter+0xd0>
  94:	e58d3004 	str	r3, [sp, #4]
  98:	e59d3004 	ldr	r3, [sp, #4]
  9c:	e3530000 	cmp	r3, #0
  a0:	e2432001 	sub	r2, r3, #1
  a4:	e58d2004 	str	r2, [sp, #4]
  a8:	1afffffa 	bne	98 <ddr_self_refresh_enter+0x98>
	    dmc0_ctl(0x48) &= (~0x10000000);
  ac:	e59f3014 	ldr	r3, [pc, #20]	; c8 <ddr_self_refresh_enter+0xc8>
  b0:	e5932120 	ldr	r2, [r3, #288]	; 0x120
  b4:	e3c22201 	bic	r2, r2, #268435456	; 0x10000000
  b8:	e5832120 	str	r2, [r3, #288]	; 0x120
	}
}
  bc:	e28dd008 	add	sp, sp, #8
  c0:	e12fff1e 	bx	lr
  c4:	73820000 	.word	0x73820000
  c8:	73500000 	.word	0x73500000
  cc:	ffc00ff7 	.word	0xffc00ff7
  d0:	0004e200 	.word	0x0004e200

Disassembly of section .text.InitRoutine_Start:

00000000 <InitRoutine_Start>:
/*===========================================================================
* FUNCTION : InitRoutine_Start(void)
* DESCRIPTION : 
===========================================================================*/
void InitRoutine_Start(void)
{
   0:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
inline static void ddr_clock_set(void)
{
	volatile int i;

	/* Change CLKCTRL soruce to XIN */
	writel(0x00001F00, addr_clk(0x000000));		// CPU (Cortex-A7)
   4:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
   8:	e3a02c1f 	mov	r2, #7936	; 0x1f00
   c:	e5832000 	str	r2, [r3]
	writel(0x00001F00, addr_clk(0x000008));		// Memory Bus	
  10:	e5832008 	str	r2, [r3, #8]
	writel(0x00200014, addr_clk(0x000014));		// io bus
  14:	e59f2604 	ldr	r2, [pc, #1540]	; 620 <InitRoutine_Start+0x620>
  18:	e5832014 	str	r2, [r3, #20]
	writel(0x00200014, addr_clk(0x000024));		// smu bus
  1c:	e5832024 	str	r2, [r3, #36]	; 0x24
	writel(0x00200014, addr_clk(0x00002C));		// cortex-M4	
  20:	e583202c 	str	r2, [r3, #44]	; 0x2c

	/* enable hsio block */
	writel(0x00000001, (void __iomem *)addr_clk(0x400100));           // pmu pwrup_hsbus
  24:	e2833501 	add	r3, r3, #4194304	; 0x400000
  28:	e3a02001 	mov	r2, #1
  2c:	e5832100 	str	r2, [r3, #256]	; 0x100
	while((readl((void __iomem *)addr_clk(0x400000)) & 0x1) == 0);       // check pwrsts0 0-bit
  30:	e5932000 	ldr	r2, [r3]
  34:	e3120001 	tst	r2, #1
  38:	0afffffc 	beq	30 <InitRoutine_Start+0x30>
	writel(readl((void __iomem *)addr_clk(0x400010))|(1<<31), \
  3c:	e5932010 	ldr	r2, [r3, #16]
  40:	e3822102 	orr	r2, r2, #-2147483648	; 0x80000000
  44:	e59f35d8 	ldr	r3, [pc, #1496]	; 624 <InitRoutine_Start+0x624>
  48:	e5832010 	str	r2, [r3, #16]
			(void __iomem *)addr_clk(0x400010));     // pmu_sysrst
	writel(readl((void __iomem *)addr_mem(0x810000))|(1<<29), \
  4c:	e24338bf 	sub	r3, r3, #12517376	; 0xbf0000
  50:	e5932000 	ldr	r2, [r3]
  54:	e3822202 	orr	r2, r2, #536870912	; 0x20000000
  58:	e5832000 	str	r2, [r3]
			(void __iomem *)addr_mem(0x810000));  // membus_hclk
	writel(readl((void __iomem *)addr_mem(0x810004))|(1<<12), \
  5c:	e5932004 	ldr	r2, [r3, #4]
  60:	e3822a01 	orr	r2, r2, #4096	; 0x1000
  64:	e5832004 	str	r2, [r3, #4]
			(void __iomem *)addr_mem(0x810004));  // membus_rst
	writel(0x00200014, (void __iomem *)addr_clk(0x000020));           // hsio bus
  68:	e59f25b0 	ldr	r2, [pc, #1456]	; 620 <InitRoutine_Start+0x620>
  6c:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
  70:	e5832020 	str	r2, [r3, #32]

inline static void ddr_setpll(void __iomem *reg, unsigned value)
{
	unsigned int i;
	if (value & (1<<31)) {
		writel((value&0x7FFFFFFF)|(1<<26), reg);
  74:	e59f25ac 	ldr	r2, [pc, #1452]	; 628 <InitRoutine_Start+0x628>
  78:	e583204c 	str	r2, [r3, #76]	; 0x4c
		for (i=100 ; i ; i--);
		writel(readl(reg) | (1<<31), reg);
  7c:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
  80:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
  84:	e3a0231d 	mov	r2, #1946157056	; 0x74000000
  88:	e582304c 	str	r3, [r2, #76]	; 0x4c
  8c:	e3a03064 	mov	r3, #100	; 0x64
		for (i=100 ; i ; i--)
			while ((readl(reg) & (1<<26)) == 0);
  90:	e592104c 	ldr	r1, [r2, #76]	; 0x4c
  94:	e3110301 	tst	r1, #67108864	; 0x4000000
  98:	0afffffc 	beq	90 <InitRoutine_Start+0x90>
	unsigned int i;
	if (value & (1<<31)) {
		writel((value&0x7FFFFFFF)|(1<<26), reg);
		for (i=100 ; i ; i--);
		writel(readl(reg) | (1<<31), reg);
		for (i=100 ; i ; i--)
  9c:	e2533001 	subs	r3, r3, #1
  a0:	1afffffa 	bne	90 <InitRoutine_Start+0x90>

inline static void ddr_setpll(void __iomem *reg, unsigned value)
{
	unsigned int i;
	if (value & (1<<31)) {
		writel((value&0x7FFFFFFF)|(1<<26), reg);
  a4:	e59f2580 	ldr	r2, [pc, #1408]	; 62c <InitRoutine_Start+0x62c>
  a8:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
  ac:	e5832050 	str	r2, [r3, #80]	; 0x50
		for (i=100 ; i ; i--);
		writel(readl(reg) | (1<<31), reg);
  b0:	e5933050 	ldr	r3, [r3, #80]	; 0x50
  b4:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
  b8:	e3a0231d 	mov	r2, #1946157056	; 0x74000000
  bc:	e5823050 	str	r3, [r2, #80]	; 0x50
  c0:	e3a03064 	mov	r3, #100	; 0x64
		for (i=100 ; i ; i--)
			while ((readl(reg) & (1<<26)) == 0);
  c4:	e5921050 	ldr	r1, [r2, #80]	; 0x50
  c8:	e3110301 	tst	r1, #67108864	; 0x4000000
  cc:	0afffffc 	beq	c4 <InitRoutine_Start+0xc4>
	unsigned int i;
	if (value & (1<<31)) {
		writel((value&0x7FFFFFFF)|(1<<26), reg);
		for (i=100 ; i ; i--);
		writel(readl(reg) | (1<<31), reg);
		for (i=100 ; i ; i--)
  d0:	e2533001 	subs	r3, r3, #1
  d4:	1afffffa 	bne	c4 <InitRoutine_Start+0xc4>

inline static void ddr_setpll(void __iomem *reg, unsigned value)
{
	unsigned int i;
	if (value & (1<<31)) {
		writel((value&0x7FFFFFFF)|(1<<26), reg);
  d8:	e59f2550 	ldr	r2, [pc, #1360]	; 630 <InitRoutine_Start+0x630>
  dc:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
  e0:	e5832048 	str	r2, [r3, #72]	; 0x48
		for (i=100 ; i ; i--);
		writel(readl(reg) | (1<<31), reg);
  e4:	e5933048 	ldr	r3, [r3, #72]	; 0x48
  e8:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
  ec:	e3a0231d 	mov	r2, #1946157056	; 0x74000000
  f0:	e5823048 	str	r3, [r2, #72]	; 0x48
  f4:	e3a03064 	mov	r3, #100	; 0x64
		for (i=100 ; i ; i--)
			while ((readl(reg) & (1<<26)) == 0);
  f8:	e5921048 	ldr	r1, [r2, #72]	; 0x48
  fc:	e3110301 	tst	r1, #67108864	; 0x4000000
 100:	0afffffc 	beq	f8 <InitRoutine_Start+0xf8>
	unsigned int i;
	if (value & (1<<31)) {
		writel((value&0x7FFFFFFF)|(1<<26), reg);
		for (i=100 ; i ; i--);
		writel(readl(reg) | (1<<31), reg);
		for (i=100 ; i ; i--)
 104:	e2533001 	subs	r3, r3, #1
 108:	1afffffa 	bne	f8 <InitRoutine_Start+0xf8>

	/* PLLs */
	ddr_setpll((void __iomem *)addr_clk(0x00004C), (1<<31)|PLL3_VALUE); // for cpu
	ddr_setpll((void __iomem *)addr_clk(0x000050), (1<<31)|PLL4_VALUE); // for mem
	ddr_setpll((void __iomem *)addr_clk(0x000048), (1<<31)|PLL2_VALUE); 
	i=3200; while(i--);
 10c:	e3a03d32 	mov	r3, #3200	; 0xc80
 110:	e58d3000 	str	r3, [sp]
 114:	e59d3000 	ldr	r3, [sp]
 118:	e3530000 	cmp	r3, #0
 11c:	e2432001 	sub	r2, r3, #1
 120:	e58d2000 	str	r2, [sp]
 124:	1afffffa 	bne	114 <InitRoutine_Start+0x114>
		writel(readl(reg) & ~(1<<31), reg);
}

inline static void ddr_setfbus(void __iomem *reg, unsigned value)
{
	writel(value, reg);
 128:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
 12c:	e3012f01 	movw	r2, #7937	; 0x1f01
 130:	e5832000 	str	r2, [r3]
	while(readl(reg) & (1<<29));
 134:	e5932000 	ldr	r2, [r3]
 138:	e3120202 	tst	r2, #536870912	; 0x20000000
 13c:	1afffffc 	bne	134 <InitRoutine_Start+0x134>
		writel(readl(reg) & ~(1<<31), reg);
}

inline static void ddr_setfbus(void __iomem *reg, unsigned value)
{
	writel(value, reg);
 140:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
 144:	e3012f01 	movw	r2, #7937	; 0x1f01
 148:	e5832008 	str	r2, [r3, #8]
	while(readl(reg) & (1<<29));
 14c:	e1a02003 	mov	r2, r3
 150:	e5923008 	ldr	r3, [r2, #8]
 154:	e3130202 	tst	r3, #536870912	; 0x20000000
 158:	1afffffc 	bne	150 <InitRoutine_Start+0x150>
		writel(readl(reg) & ~(1<<31), reg);
}

inline static void ddr_setfbus(void __iomem *reg, unsigned value)
{
	writel(value, reg);
 15c:	e59f24d0 	ldr	r2, [pc, #1232]	; 634 <InitRoutine_Start+0x634>
 160:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
 164:	e5832014 	str	r2, [r3, #20]
	while(readl(reg) & (1<<29));
 168:	e1a02003 	mov	r2, r3
 16c:	e5923014 	ldr	r3, [r2, #20]
 170:	e3130202 	tst	r3, #536870912	; 0x20000000
 174:	1afffffc 	bne	16c <InitRoutine_Start+0x16c>
		writel(readl(reg) & ~(1<<31), reg);
}

inline static void ddr_setfbus(void __iomem *reg, unsigned value)
{
	writel(value, reg);
 178:	e59f24b4 	ldr	r2, [pc, #1204]	; 634 <InitRoutine_Start+0x634>
 17c:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
 180:	e5832020 	str	r2, [r3, #32]
	while(readl(reg) & (1<<29));
 184:	e1a02003 	mov	r2, r3
 188:	e5923020 	ldr	r3, [r2, #32]
 18c:	e3130202 	tst	r3, #536870912	; 0x20000000
 190:	1afffffc 	bne	188 <InitRoutine_Start+0x188>
		writel(readl(reg) & ~(1<<31), reg);
}

inline static void ddr_setfbus(void __iomem *reg, unsigned value)
{
	writel(value, reg);
 194:	e59f2498 	ldr	r2, [pc, #1176]	; 634 <InitRoutine_Start+0x634>
 198:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
 19c:	e5832024 	str	r2, [r3, #36]	; 0x24
	while(readl(reg) & (1<<29));
 1a0:	e1a02003 	mov	r2, r3
 1a4:	e5923024 	ldr	r3, [r2, #36]	; 0x24
 1a8:	e3130202 	tst	r3, #536870912	; 0x20000000
 1ac:	1afffffc 	bne	1a4 <InitRoutine_Start+0x1a4>
		writel(readl(reg) & ~(1<<31), reg);
}

inline static void ddr_setfbus(void __iomem *reg, unsigned value)
{
	writel(value, reg);
 1b0:	e59f247c 	ldr	r2, [pc, #1148]	; 634 <InitRoutine_Start+0x634>
 1b4:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
 1b8:	e583202c 	str	r2, [r3, #44]	; 0x2c
	while(readl(reg) & (1<<29));
 1bc:	e1a02003 	mov	r2, r3
 1c0:	e592302c 	ldr	r3, [r2, #44]	; 0x2c
 1c4:	e3130202 	tst	r3, #536870912	; 0x20000000
 1c8:	1afffffc 	bne	1c0 <InitRoutine_Start+0x1c0>
	ddr_setfbus((void __iomem *)addr_clk(0x000008), 0x00001F01);	// Memory Bus
	ddr_setfbus((void __iomem *)addr_clk(0x000014), 0x00200012);	// io bus
	ddr_setfbus((void __iomem *)addr_clk(0x000020), 0x00200012);    // hsio bus
	ddr_setfbus((void __iomem *)addr_clk(0x000024), 0x00200012);	// smu bus
	ddr_setfbus((void __iomem *)addr_clk(0x00002C), 0x00200012);	// cortex-M4
	i=3200; while(i--);
 1cc:	e3a03d32 	mov	r3, #3200	; 0xc80
 1d0:	e58d3000 	str	r3, [sp]
 1d4:	e59d3000 	ldr	r3, [sp]
 1d8:	e3530000 	cmp	r3, #0
 1dc:	e2432001 	sub	r2, r3, #1
 1e0:	e58d2000 	str	r2, [sp]
 1e4:	1afffffa 	bne	1d4 <InitRoutine_Start+0x1d4>

	writel(0x24000000, addr_clk(0x0000D4));		// sdmmc0 peri (24MHz)	// for emmcboot
 1e8:	e3a0331d 	mov	r3, #1946157056	; 0x74000000
 1ec:	e3a02309 	mov	r2, #603979776	; 0x24000000
 1f0:	e58320d4 	str	r2, [r3, #212]	; 0xd4
	writel(0x24000000, addr_clk(0x0000D8));		// sdmmc1 peri (24MHz)	// for emmcboot
 1f4:	e58320d8 	str	r2, [r3, #216]	; 0xd8
	writel(0x24000000, addr_clk(0x0000DC));		// sdmmc2 peri (24MHz)	// for emmcboot
 1f8:	e58320dc 	str	r2, [r3, #220]	; 0xdc
	writel(0x24000000, addr_clk(0x0000E0));		// sdmmc3 peri (24MHz)	// for emmcboot
 1fc:	e58320e0 	str	r2, [r3, #224]	; 0xe0
	i=3200; while(i--);
 200:	e3a03d32 	mov	r3, #3200	; 0xc80
 204:	e58d3000 	str	r3, [sp]
 208:	e59d3000 	ldr	r3, [sp]
 20c:	e3530000 	cmp	r3, #0
 210:	e2432001 	sub	r2, r3, #1
 214:	e58d2000 	str	r2, [sp]
 218:	1afffffa 	bne	208 <InitRoutine_Start+0x208>
	nCL = 9;
	nCWL = 7;
#endif

// PHY Setting
	dmc0_phy(0x5C) = 0x1; // UNIQUIFY_IO_1
 21c:	e59f3414 	ldr	r3, [pc, #1044]	; 638 <InitRoutine_Start+0x638>
 220:	e3a02001 	mov	r2, #1
 224:	e5832170 	str	r2, [r3, #368]	; 0x170
	while(!(dmc0_phy(0x5c)&0x2));
 228:	e5931170 	ldr	r1, [r3, #368]	; 0x170
 22c:	e59f2404 	ldr	r2, [pc, #1028]	; 638 <InitRoutine_Start+0x638>
 230:	e3110002 	tst	r1, #2
 234:	0afffffb 	beq	228 <InitRoutine_Start+0x228>
	dmc0_phy(0x5C) = 0x5;	
 238:	e3a03005 	mov	r3, #5

	temp = dmc0_phy(0x5C);

	for(i=0 ; i<MEM_STRB_WIDTH ; i++)
	{
		dmc0_phy(0x4B) = SLV_DLY_WIDTH*i;
 23c:	e3a0c006 	mov	ip, #6
		if(TRIM1 < 0)
			temp = temp & ~(1<<i);
	else
			temp = temp | (1<<i);
		dmc0_phy(0x59) = temp;
		dmc0_phy(0x4c) = abs(TRIM1);
 240:	e1a04003 	mov	r4, r3
		if(TRIM3 < 0)
			temp = temp & ~(1<<i);
		else
			temp = temp | (1<<i);
		dmc0_phy(0x5A) = temp;
		dmc0_phy(0x4E) = abs(TRIM3);
 244:	e3a05008 	mov	r5, #8
#endif

// PHY Setting
	dmc0_phy(0x5C) = 0x1; // UNIQUIFY_IO_1
	while(!(dmc0_phy(0x5c)&0x2));
	dmc0_phy(0x5C) = 0x5;	
 248:	e5823170 	str	r3, [r2, #368]	; 0x170
	dmc0_phy(0x5C) = 0x1;	
 24c:	e3a01001 	mov	r1, #1
 250:	e5821170 	str	r1, [r2, #368]	; 0x170

	temp = dmc0_phy(0x5C);
 254:	e5920170 	ldr	r0, [r2, #368]	; 0x170

	for(i=0 ; i<MEM_STRB_WIDTH ; i++)
 258:	e3a00000 	mov	r0, #0
 25c:	e58d0004 	str	r0, [sp, #4]
 260:	e59d0004 	ldr	r0, [sp, #4]
 264:	e59f33cc 	ldr	r3, [pc, #972]	; 638 <InitRoutine_Start+0x638>
 268:	e3500003 	cmp	r0, #3
 26c:	ca000010 	bgt	2b4 <InitRoutine_Start+0x2b4>
	{
		dmc0_phy(0x4B) = SLV_DLY_WIDTH*i;
 270:	e59d3004 	ldr	r3, [sp, #4]
 274:	e003039c 	mul	r3, ip, r3
 278:	e582312c 	str	r3, [r2, #300]	; 0x12c

		temp = dmc0_phy(0x59);
 27c:	e5923164 	ldr	r3, [r2, #356]	; 0x164
		if(TRIM1 < 0)
			temp = temp & ~(1<<i);
 280:	e59d0004 	ldr	r0, [sp, #4]
 284:	e1c33011 	bic	r3, r3, r1, lsl r0
	else
			temp = temp | (1<<i);
		dmc0_phy(0x59) = temp;
 288:	e5823164 	str	r3, [r2, #356]	; 0x164
		dmc0_phy(0x4c) = abs(TRIM1);
 28c:	e5824130 	str	r4, [r2, #304]	; 0x130

		temp = dmc0_phy(0x5A);
 290:	e5923168 	ldr	r3, [r2, #360]	; 0x168
		if(TRIM3 < 0)
			temp = temp & ~(1<<i);
 294:	e59d0004 	ldr	r0, [sp, #4]
 298:	e1c33011 	bic	r3, r3, r1, lsl r0
		else
			temp = temp | (1<<i);
		dmc0_phy(0x5A) = temp;
 29c:	e5823168 	str	r3, [r2, #360]	; 0x168
		dmc0_phy(0x4E) = abs(TRIM3);
 2a0:	e5825138 	str	r5, [r2, #312]	; 0x138
	dmc0_phy(0x5C) = 0x5;	
	dmc0_phy(0x5C) = 0x1;	

	temp = dmc0_phy(0x5C);

	for(i=0 ; i<MEM_STRB_WIDTH ; i++)
 2a4:	e59d3004 	ldr	r3, [sp, #4]
 2a8:	e2833001 	add	r3, r3, #1
 2ac:	e58d3004 	str	r3, [sp, #4]
 2b0:	eaffffea 	b	260 <InitRoutine_Start+0x260>
		dmc0_phy(0x5A) = temp;
		dmc0_phy(0x4E) = abs(TRIM3);

	}

	dmc0_phy(0x6D) = (0<<20)|(0<<16)|1; // SCL_WINDOW_TRIM
 2b4:	e3a02001 	mov	r2, #1
	dmc0_phy(0x49) = ((0xA)<<28)|0x1000; // PHY_DLL_RECALIB
	dmc0_phy(0x57) = 0; //0x01000000; // UNQ_ANALOG_DLL_1


	dmc0_phy(0x48) = (0<<31)|(PREAMBLE_DLY<<29)|(1<<28)|(0<<24)|(0xf<<20)|(0xf<<16)|(0<<15)|(HALF_RATE_MODE<<14)|(0<<9)|(EXTRA_ONE_CLK<<8)|(MEMCTRL_DDS<<4)|MEMCTRL_TERM;
 2b8:	e59f137c 	ldr	r1, [pc, #892]	; 63c <InitRoutine_Start+0x63c>
		dmc0_phy(0x5A) = temp;
		dmc0_phy(0x4E) = abs(TRIM3);

	}

	dmc0_phy(0x6D) = (0<<20)|(0<<16)|1; // SCL_WINDOW_TRIM
 2bc:	e58321b4 	str	r2, [r3, #436]	; 0x1b4
	dmc0_phy(0x49) = ((0xA)<<28)|0x1000; // PHY_DLL_RECALIB
 2c0:	e59f2378 	ldr	r2, [pc, #888]	; 640 <InitRoutine_Start+0x640>
 2c4:	e5832124 	str	r2, [r3, #292]	; 0x124
	dmc0_phy(0x57) = 0; //0x01000000; // UNQ_ANALOG_DLL_1
 2c8:	e3a02000 	mov	r2, #0
 2cc:	e583215c 	str	r2, [r3, #348]	; 0x15c


	dmc0_phy(0x48) = (0<<31)|(PREAMBLE_DLY<<29)|(1<<28)|(0<<24)|(0xf<<20)|(0xf<<16)|(0<<15)|(HALF_RATE_MODE<<14)|(0<<9)|(EXTRA_ONE_CLK<<8)|(MEMCTRL_DDS<<4)|MEMCTRL_TERM;
 2d0:	e5831120 	str	r1, [r3, #288]	; 0x120
	// PHY_PAD_CTRL
	// reset_en_state, preamble_dly, receiver_en, clk_adjust_phy,clk_drive,adrctrl_drive,ddr1p2,half_rate,no_external_dll,extra_oen_clk,dq_dqs_drive,io_mode,odt_en,odt_sel

	dmc0_phy(0x46) = (1<<24)|(0<<16)|(0<<12)|(round_up(nCL,2)<<4)|(0<<3)|(1<<2)|(0<<1)|1;
 2d4:	e59f1368 	ldr	r1, [pc, #872]	; 644 <InitRoutine_Start+0x644>
 2d8:	e5831118 	str	r1, [r3, #280]	; 0x118
	// SCL_CONFIG_1
	// ddr_odt_ctl_wr, ddr_odt_ctrl_rd, local_odt_ctrl, rd_cas_latency, dly_dfi_phyupd_ack, ddr3, ddr2, burst8

	dmc0_phy(0x47) = (SWAP_PHASE<<31)|(0<<30)|(0<<29)|(0<<28)|(1<<25)|((HALF_RATE_MODE && (((nCWL%2==0)?1:0)^SWAP_PHASE))<<24)|(0<<12)|(round_up(nCWL,2)<<8)|1;
 2dc:	e59f1364 	ldr	r1, [pc, #868]	; 648 <InitRoutine_Start+0x648>
 2e0:	e583111c 	str	r1, [r3, #284]	; 0x11c
	// swap_phase,rdfifo_enable,lpddr2,analog_dll_for_scl,scl_step,size,dly_dfi_wrdata,double_ref_dly,wr_cas,latency,scl_test_cs

	dmc0_phy(0x6F) = ((nCWL%2==0) && SWAP_PHASE);
	// SCL_CONFIG_4

	dmc0_phy(0x54) = (((RTT_WR<<9)|((nCWL-5)<<3))<<16)|(((nCWL-5)<<3));
 2e4:	e59f1360 	ldr	r1, [pc, #864]	; 64c <InitRoutine_Start+0x64c>

	dmc0_phy(0x47) = (SWAP_PHASE<<31)|(0<<30)|(0<<29)|(0<<28)|(1<<25)|((HALF_RATE_MODE && (((nCWL%2==0)?1:0)^SWAP_PHASE))<<24)|(0<<12)|(round_up(nCWL,2)<<8)|1;
	// SCL_CONFIG_2
	// swap_phase,rdfifo_enable,lpddr2,analog_dll_for_scl,scl_step,size,dly_dfi_wrdata,double_ref_dly,wr_cas,latency,scl_test_cs

	dmc0_phy(0x6F) = ((nCWL%2==0) && SWAP_PHASE);
 2e8:	e58321bc 	str	r2, [r3, #444]	; 0x1bc
	// SCL_CONFIG_4

	dmc0_phy(0x54) = (((RTT_WR<<9)|((nCWL-5)<<3))<<16)|(((nCWL-5)<<3));
 2ec:	e5831150 	str	r1, [r3, #336]	; 0x150
	// WRLVL_DYN_ODT
	// dynamic_odt_on, dynamic_odt_off

	dmc0_phy(0x5B) = (~SCL_LANES&((1<<MEM_STRB_WIDTH)-1));
 2f0:	e583216c 	str	r2, [r3, #364]	; 0x16c
		//unsigned bit_lvl_wr_failure_status; // Read-only
		unsigned bit_lvl_wr_side_read_lat = (READ_LAT);
		unsigned bit_lvl_wr_side_trim_lat = (TRIM_LAT); 
		unsigned dynamic_write_bit_leveling = 0;

		dmc0_phy(0x70) =  (bit_lvl_wr_side_read_lat<<12)|(bit_lvl_wr_side_trim_lat<<4)|dynamic_write_bit_leveling;
 2f4:	e59f2354 	ldr	r2, [pc, #852]	; 650 <InitRoutine_Start+0x650>
 2f8:	e58321c0 	str	r2, [r3, #448]	; 0x1c0

	{
		unsigned wr_lvl_on = (1<<7)|(((RTT_NOM&0x4)<<7)|((RTT_NOM&0x2)<<5)|((RTT_NOM&0x1)<<2))|(((DIC&0x2)<<4)|((DIC&0x1)<<1));
		unsigned wr_lvl_off = (((RTT_NOM&0x4)<<7)|((RTT_NOM&0x2)<<5)|((RTT_NOM&0x1)<<2))|(((DIC&0x2)<<4)|((DIC&0x1)<<1));

		dmc0_phy(0x55) = (wr_lvl_on<<16)|(wr_lvl_off<<0);
 2fc:	e59f2350 	ldr	r2, [pc, #848]	; 654 <InitRoutine_Start+0x654>
 300:	e5832154 	str	r2, [r3, #340]	; 0x154
		unsigned mas_dll_dly = 0;
		unsigned mas_dll_dly_by_2 = 0;

		while(mas_dll_dly ==0)
		{
			mas_dll_dly = dmc0_phy(0x4A);
 304:	e5931128 	ldr	r1, [r3, #296]	; 0x128
 308:	e59f2328 	ldr	r2, [pc, #808]	; 638 <InitRoutine_Start+0x638>

	{
		unsigned mas_dll_dly = 0;
		unsigned mas_dll_dly_by_2 = 0;

		while(mas_dll_dly ==0)
 30c:	e1b01c21 	lsrs	r1, r1, #24
 310:	0afffffb 	beq	304 <InitRoutine_Start+0x304>
	}


		for(i=0 ; i<MEM_CLOCKS ; i++)
		{
			dmc0_phy(0x4B) = i*(SLV_DLY_WIDTH+1);
 314:	e3a01007 	mov	r1, #7
				if(DLLS_TRIM < 0)
					val = val & ~(1<<6);
				else
					val = val | (1<<6);

				dmc0_phy(0x69) = val;
 318:	e3a0004a 	mov	r0, #74	; 0x4a
		{
			mas_dll_dly = dmc0_phy(0x4A);
			mas_dll_dly = mas_dll_dly >> 24;
	}

		mas_dll_dly = dmc0_phy(0x4A);			
 31c:	e5923128 	ldr	r3, [r2, #296]	; 0x128
			if(DLLS_TRIM_ADRCTRL > 0)
				val = val | (1<<9);
			else
				val = val & (~(1<<9));
	
			dmc0_phy(0x4A) = val;
 320:	e3003205 	movw	r3, #517	; 0x205
 324:	e5823128 	str	r3, [r2, #296]	; 0x128
			else
				dmc0_phy(0x4A) = 0x200 | mas_dll_dly;
	}


		for(i=0 ; i<MEM_CLOCKS ; i++)
 328:	e3a03000 	mov	r3, #0
 32c:	e58d3004 	str	r3, [sp, #4]
 330:	e59d3004 	ldr	r3, [sp, #4]
 334:	e3530001 	cmp	r3, #1
 338:	e59f32f8 	ldr	r3, [pc, #760]	; 638 <InitRoutine_Start+0x638>
 33c:	ca000007 	bgt	360 <InitRoutine_Start+0x360>
		{
			dmc0_phy(0x4B) = i*(SLV_DLY_WIDTH+1);
 340:	e59d3004 	ldr	r3, [sp, #4]
 344:	e0030391 	mul	r3, r1, r3
 348:	e582312c 	str	r3, [r2, #300]	; 0x12c
				if(DLLS_TRIM < 0)
					val = val & ~(1<<6);
				else
					val = val | (1<<6);

				dmc0_phy(0x69) = val;
 34c:	e58201a4 	str	r0, [r2, #420]	; 0x1a4
			else
				dmc0_phy(0x4A) = 0x200 | mas_dll_dly;
	}


		for(i=0 ; i<MEM_CLOCKS ; i++)
 350:	e59d3004 	ldr	r3, [sp, #4]
 354:	e2833001 	add	r3, r3, #1
 358:	e58d3004 	str	r3, [sp, #4]
 35c:	eafffff3 	b	330 <InitRoutine_Start+0x330>
			if(DLLS_TRIM_ADRCTRL_MA > 0)
				val = val | (1<<27);
			else
				val = val & ~(1<<27);

			dmc0_phy(0x49) = MASTER_DLL | val;
 360:	e59f22f0 	ldr	r2, [pc, #752]	; 658 <InitRoutine_Start+0x658>
	dmc0_ctl(0x14) = (1<<6)|(0<<4)|(HALF_RATE_MODE<<3)|DRAM_MEM_WIDTH;

	for(i=0 ; i<NUM_AGENTS ; i++)
	{
		dmc0_ctl(0x0) = i*MIN_CMDACPT_WIDTH;
		dmc0_ctl(0x3) = 4;
 364:	e3a01004 	mov	r1, #4
			if(DLLS_TRIM_ADRCTRL_MA > 0)
				val = val | (1<<27);
			else
				val = val & ~(1<<27);

			dmc0_phy(0x49) = MASTER_DLL | val;
 368:	e5832124 	str	r2, [r3, #292]	; 0x124
		}

	}	


	dmc0_phy(0x43) = (SCL_WAIT_LATENCY<<12)|(ANALOG_DLL_FOR_SCL<<9)|(0<<8)|(MAIN_CLK_DLY<<4)|6;
 36c:	e3052076 	movw	r2, #20598	; 0x5076
 370:	e583210c 	str	r2, [r3, #268]	; 0x10c
	if(OP_DQS_TRIM_UPD)
		unq_set_op_dqs_trim(0);

// Controller set init value

	dmc0_ctl(0x14) = (1<<6)|(0<<4)|(HALF_RATE_MODE<<3)|DRAM_MEM_WIDTH;
 374:	e3a03048 	mov	r3, #72	; 0x48
 378:	e59f22dc 	ldr	r2, [pc, #732]	; 65c <InitRoutine_Start+0x65c>
 37c:	e5823050 	str	r3, [r2, #80]	; 0x50

	for(i=0 ; i<NUM_AGENTS ; i++)
 380:	e3a03000 	mov	r3, #0
 384:	e58d3004 	str	r3, [sp, #4]
 388:	e59d3004 	ldr	r3, [sp, #4]
 38c:	e3530001 	cmp	r3, #1
 390:	e59f32c4 	ldr	r3, [pc, #708]	; 65c <InitRoutine_Start+0x65c>
 394:	ca000007 	bgt	3b8 <InitRoutine_Start+0x3b8>
	{
		dmc0_ctl(0x0) = i*MIN_CMDACPT_WIDTH;
 398:	e59d3004 	ldr	r3, [sp, #4]
 39c:	e1a03183 	lsl	r3, r3, #3
 3a0:	e5823000 	str	r3, [r2]
		dmc0_ctl(0x3) = 4;
 3a4:	e582100c 	str	r1, [r2, #12]

// Controller set init value

	dmc0_ctl(0x14) = (1<<6)|(0<<4)|(HALF_RATE_MODE<<3)|DRAM_MEM_WIDTH;

	for(i=0 ; i<NUM_AGENTS ; i++)
 3a8:	e59d3004 	ldr	r3, [sp, #4]
 3ac:	e2833001 	add	r3, r3, #1
 3b0:	e58d3004 	str	r3, [sp, #4]
 3b4:	eafffff3 	b	388 <InitRoutine_Start+0x388>
		//unsigned mem_config_5;
		//int mode = 0;

		address_mapping(0);

		dmc0_ctl(0x5) = (en_auto_prech<<30)|(0<<29)|(col_addr_high_rshift<<24)|(0<<21)|(cs_addr_rshift<<16)|(0<<13)|(bank_addr_rshift<<8)|(0<<5)|row_addr_rshift;
 3b8:	e59f22a0 	ldr	r2, [pc, #672]	; 660 <InitRoutine_Start+0x660>
		}

		dmc0_ctl(0x15) = ((tXS-1)<<24)|(ZQC_SHORT<<23)|(AUTO_ZQC_ENABLE<<22)|ZQC_INTERVAL;
		// ZQC_CONFIG

		dmc0_ctl(0x16) = (0<<16)|2;
 3bc:	e3a01002 	mov	r1, #2
		// AUTO_SCL_CTRL

		#if defined(CONFIG_DDR3_2CS)
		dmc0_ctl(0x10) = 0*MEM_CHIP_SELECTS; // ODT_CONFIG
		dmc0_ctl(0x13) = (3<<16)|2;			 // ODT_EN_CONFIG
 3c0:	e59f029c 	ldr	r0, [pc, #668]	; 664 <InitRoutine_Start+0x664>
		//unsigned mem_config_5;
		//int mode = 0;

		address_mapping(0);

		dmc0_ctl(0x5) = (en_auto_prech<<30)|(0<<29)|(col_addr_high_rshift<<24)|(0<<21)|(cs_addr_rshift<<16)|(0<<13)|(bank_addr_rshift<<8)|(0<<5)|row_addr_rshift;
 3c4:	e5832014 	str	r2, [r3, #20]
		// MEM_CONFIG_1
		dmc0_ctl(0x6) = (dfi_dram_clk_disable<<21)|(dfi_init_start<<20)|(row_addr_mask<<0);
 3c8:	e3072fff 	movw	r2, #32767	; 0x7fff
 3cc:	e5832018 	str	r2, [r3, #24]
		// MEM_CONFIG_2
		dmc0_ctl(0x7) = (aprech_bit_pos<<16)|(col_addr_high_mask);
 3d0:	e59f2290 	ldr	r2, [pc, #656]	; 668 <InitRoutine_Start+0x668>
 3d4:	e583201c 	str	r2, [r3, #28]
		// MEM_CONFIG_3
		dmc0_ctl(0x8)  = col_addr_low_mask;
 3d8:	e3a02007 	mov	r2, #7
 3dc:	e5832020 	str	r2, [r3, #32]
		// MEM_CONFIG_4
		dmc0_ctl(0x9) = (bank_addr_high_rshift<<24)|(bank_addr_high_mask<<16)|(cs_addr_mask<<8)|(bank_addr_mask);
 3e0:	e2822b02 	add	r2, r2, #2048	; 0x800
 3e4:	e5832024 	str	r2, [r3, #36]	; 0x24
		// MEM_CONFIG_5
	}

	dmc0_ctl(0xB) = (0<<22)|(17<<12)|(0x3f<<4)|(0<<3)|(0<<2)|(0<<1)|0;
 3e8:	e59f227c 	ldr	r2, [pc, #636]	; 66c <InitRoutine_Start+0x66c>
 3ec:	e583202c 	str	r2, [r3, #44]	; 0x2c
		tXP       = max(max(DDR3_tXP_ck, round_up(DDR3_tXP_ps, 2*tCK)), tCKE);
		sref_exit = HALF_RATE_MODE ? max(round_up(DDR3_tDLLK_ck, 2) - tXS, round_up(DDR3_tZQOPER_ck, 2))-2 :
		                               max(DDR3_tDLLK_ck               -tXS, DDR3_tZQOPER_ck             )-2 ;


		dmc0_ctl(0xA) = (1<<28)|(8<<24)|((round_up(DDR3_tRFC_ps, 2*tCK)-2)<<16)|(round_up(DDR3_tREFI_ps, 2*tCK)-2);
 3f0:	e59f2278 	ldr	r2, [pc, #632]	; 670 <InitRoutine_Start+0x670>
 3f4:	e5832028 	str	r2, [r3, #40]	; 0x28
		//REF_CONFIG

		dmc0_ctl(0xC) = (rmw_dly<<28)|(rd2wr_dly<<24)|(wr2wr_csc_dly<<20)|(wr2wr_dly<<16)|(rd2rd_csc_dly<<12)|(rd2rd_dly<<8)|(wr2rd_csc_dly<<4)|wr2rd_dly;
 3f8:	e59f2274 	ldr	r2, [pc, #628]	; 674 <InitRoutine_Start+0x674>
 3fc:	e5832030 	str	r2, [r3, #48]	; 0x30
		// DLY_CONFIG_1

		dmc0_ctl(0xD) = (((sref_exit & (1<<8))>>8)<<30)|
 400:	e59f2270 	ldr	r2, [pc, #624]	; 678 <InitRoutine_Start+0x678>
 404:	e5832034 	str	r2, [r3, #52]	; 0x34
			//unsigned wr2prech_dly     = ret4(wr2prech_dly);
			unsigned rd2prech_dly     = (HALF_RATE_MODE ? (max(round_up(DDR3_tRTP_ps, 2*tCK), round_up(DDR3_tRTP_ck, 2)) - 1) :
			                                 (max(round_up(DDR3_tRTP_ps, 2*tCK), DDR3_tRTP_ck) - 1));
			unsigned prech_all_dly    = round_up(DDR3_tRP_ps, 2*tCK);

			dmc0_ctl(0xE) = (rd_burst_end_dly<<28)|(prech2ras_dly<<24)|(ras2cas_dly<<20)|(ras2ras_dly<<16)|(wr2prech_dly<<12)|(rd2prech_dly<<8)|(prech_all_dly<<0);
 408:	e59f226c 	ldr	r2, [pc, #620]	; 67c <InitRoutine_Start+0x67c>
 40c:	e5832038 	str	r2, [r3, #56]	; 0x38
			unsigned tfaw_dly = round_up(DDR3_tFAW_ps, 2*tCK)-1;
			unsigned ras2ras_same_bank_dly = round_up(DDR3_tRC_ps, 2*tCK)-1;
			unsigned swap_phase = SWAP_PHASE;
			unsigned ras2prech_dly = round_up(DDR3_tRAS_ps, 2*tCK)-1;

			dmc0_ctl(0xf) = ((zqc_dly<<24)|(tfaw_dly<<16)|(ras2ras_same_bank_dly<<8)|(swap_phase<<5)|(ras2prech_dly<<0));
 410:	e59f2268 	ldr	r2, [pc, #616]	; 680 <InitRoutine_Start+0x680>
 414:	e583203c 	str	r2, [r3, #60]	; 0x3c
			// DLY_CONFIG_4
		}

		dmc0_ctl(0x15) = ((tXS-1)<<24)|(ZQC_SHORT<<23)|(AUTO_ZQC_ENABLE<<22)|ZQC_INTERVAL;
 418:	e59f2264 	ldr	r2, [pc, #612]	; 684 <InitRoutine_Start+0x684>
 41c:	e5832054 	str	r2, [r3, #84]	; 0x54

		dmc0_ctl(0x16) = (0<<16)|2;
		// AUTO_SCL_CTRL

		#if defined(CONFIG_DDR3_2CS)
		dmc0_ctl(0x10) = 0*MEM_CHIP_SELECTS; // ODT_CONFIG
 420:	e3a02000 	mov	r2, #0
		}

		dmc0_ctl(0x15) = ((tXS-1)<<24)|(ZQC_SHORT<<23)|(AUTO_ZQC_ENABLE<<22)|ZQC_INTERVAL;
		// ZQC_CONFIG

		dmc0_ctl(0x16) = (0<<16)|2;
 424:	e5831058 	str	r1, [r3, #88]	; 0x58
		// AUTO_SCL_CTRL

		#if defined(CONFIG_DDR3_2CS)
		dmc0_ctl(0x10) = 0*MEM_CHIP_SELECTS; // ODT_CONFIG
 428:	e5832040 	str	r2, [r3, #64]	; 0x40
		dmc0_ctl(0x13) = (3<<16)|2;			 // ODT_EN_CONFIG
 42c:	e583004c 	str	r0, [r3, #76]	; 0x4c
}

inline static void  HOST_CMD_LOAD0(unsigned a, unsigned b, unsigned c, unsigned d)
{
	(*(volatile unsigned long *)(0x73500080+a*4))=c; 
	(*(volatile unsigned long *)(0x735000C0+a*4))=((max(d,1)-1)<<12)|b;
 430:	e3a00901 	mov	r0, #16384	; 0x4000
		// AUTO_SCL_CTRL

		#if defined(CONFIG_DDR3_2CS)
		dmc0_ctl(0x10) = 0*MEM_CHIP_SELECTS; // ODT_CONFIG
		dmc0_ctl(0x13) = (3<<16)|2;			 // ODT_EN_CONFIG
		dmc0_ctl(0x10) = 1*MEM_CHIP_SELECTS; // ODT_CONFIG
 434:	e5831040 	str	r1, [r3, #64]	; 0x40
		dmc0_ctl(0x13) = (3<<16)|1;			 // ODT_EN_CONFIG
 438:	e59f1248 	ldr	r1, [pc, #584]	; 688 <InitRoutine_Start+0x688>
 43c:	e583104c 	str	r1, [r3, #76]	; 0x4c
			#endif
			unsigned odt_wr_set_dly = 1;
			unsigned odt_rd_set_dly = (HALF_RATE_MODE) ? ( (nCL - nCWL - (nCL - nCWL > 0 ? 1 : 0))/2 ) : (RL-WL);
			unsigned odt_en_sel =  0;			
	
			dmc0_ctl(0x10) = (odt_len_wr<<20)|(odt_len_rd<<16)|(odt_wr_set_dly<<12)|(odt_rd_set_dly<<8)|odt_en_sel;
 440:	e59f1244 	ldr	r1, [pc, #580]	; 68c <InitRoutine_Start+0x68c>
 444:	e5831040 	str	r1, [r3, #64]	; 0x40
			// ODT_CONFIG
		}
	 
		dmc0_ctl(0x11) = (BIG_ENDIAN<<31)|(7<<28)|(3<<24)|((RL-3-C2D)<<16)|(0<<12)|(0<<8)|(0<<4)|(WL-C2D-1-(nCWL%2 == 0 && !SWAP_PHASE && HALF_RATE_MODE));
 448:	e59f1240 	ldr	r1, [pc, #576]	; 690 <InitRoutine_Start+0x690>
 44c:	e5831044 	str	r1, [r3, #68]	; 0x44
		//DATA_XFR_CONFIG
	}


// dram init
	dmc0_ctl(0x4) = 1; // MEM_START
 450:	e3a01001 	mov	r1, #1
 454:	e5831010 	str	r1, [r3, #16]
	dmc0_ctl(0x50/4) = 0x00000048;
 458:	e3a01048 	mov	r1, #72	; 0x48
 45c:	e5831050 	str	r1, [r3, #80]	; 0x50
	i=3200; while(i--);
}

inline static void  HOST_CMD_LOAD0(unsigned a, unsigned b, unsigned c, unsigned d)
{
	(*(volatile unsigned long *)(0x73500080+a*4))=c; 
 460:	e59f122c 	ldr	r1, [pc, #556]	; 694 <InitRoutine_Start+0x694>
 464:	e5831080 	str	r1, [r3, #128]	; 0x80
	(*(volatile unsigned long *)(0x735000C0+a*4))=((max(d,1)-1)<<12)|b;
 468:	e58300c0 	str	r0, [r3, #192]	; 0xc0
	i=3200; while(i--);
}

inline static void  HOST_CMD_LOAD0(unsigned a, unsigned b, unsigned c, unsigned d)
{
	(*(volatile unsigned long *)(0x73500080+a*4))=c; 
 46c:	e5831084 	str	r1, [r3, #132]	; 0x84
	(*(volatile unsigned long *)(0x735000C0+a*4))=((max(d,1)-1)<<12)|b;
 470:	e58320c4 	str	r2, [r3, #196]	; 0xc4
	if (!no_reset) {
		HOST_CMD_LOAD0(0, 0, CKE_LOW, round_up(max(10000, 5*tCK), wait_cycle));
		HOST_CMD_LOAD0(1, 0, CKE_LOW, 0);
	}

	dmc0_ctl(0x12) = 0x11; // HOST_CMD_ISSUE
 474:	e3a02011 	mov	r2, #17
 478:	e5832048 	str	r2, [r3, #72]	; 0x48
//	while(dmc0_ctl(0x12)&0x10); //

	i=3200; while(i--);
 47c:	e3a03d32 	mov	r3, #3200	; 0xc80
 480:	e58d3004 	str	r3, [sp, #4]
 484:	e59d3004 	ldr	r3, [sp, #4]
 488:	e3530000 	cmp	r3, #0
 48c:	e2432001 	sub	r2, r3, #1
 490:	e58d2004 	str	r2, [sp, #4]
 494:	1afffffa 	bne	484 <InitRoutine_Start+0x484>
#if defined(CONFIG_DRAM_16BIT_USED)
	dmc0_ctl(0x14) = 0x0000005A;
#else
	dmc0_ctl(0x14) = 0x00000058;
 498:	e59f31bc 	ldr	r3, [pc, #444]	; 65c <InitRoutine_Start+0x65c>
 49c:	e3a02058 	mov	r2, #88	; 0x58
 4a0:	e5832050 	str	r2, [r3, #80]	; 0x50
#endif

	i=3200; while(i--);
 4a4:	e3a02d32 	mov	r2, #3200	; 0xc80
 4a8:	e58d2004 	str	r2, [sp, #4]
 4ac:	e59d2004 	ldr	r2, [sp, #4]
 4b0:	e3520000 	cmp	r2, #0
 4b4:	e2421001 	sub	r1, r2, #1
 4b8:	e58d1004 	str	r1, [sp, #4]
 4bc:	1afffffa 	bne	4ac <InitRoutine_Start+0x4ac>
	i=3200; while(i--);
}

inline static void  HOST_CMD_LOAD0(unsigned a, unsigned b, unsigned c, unsigned d)
{
	(*(volatile unsigned long *)(0x73500080+a*4))=c; 
 4c0:	e3e024ff 	mvn	r2, #-16777216	; 0xff000000
 4c4:	e5832080 	str	r2, [r3, #128]	; 0x80
	(*(volatile unsigned long *)(0x735000C0+a*4))=((max(d,1)-1)<<12)|b;
 4c8:	e3a02a7d 	mov	r2, #512000	; 0x7d000
 4cc:	e58320c0 	str	r2, [r3, #192]	; 0xc0
	i=3200; while(i--);
}

inline static void  HOST_CMD_LOAD0(unsigned a, unsigned b, unsigned c, unsigned d)
{
	(*(volatile unsigned long *)(0x73500080+a*4))=c; 
 4d0:	e59f21c0 	ldr	r2, [pc, #448]	; 698 <InitRoutine_Start+0x698>
 4d4:	e5832084 	str	r2, [r3, #132]	; 0x84
	(*(volatile unsigned long *)(0x735000C0+a*4))=((max(d,1)-1)<<12)|b;
 4d8:	e3012202 	movw	r2, #4610	; 0x1202
 4dc:	e58320c4 	str	r2, [r3, #196]	; 0xc4
	i=3200; while(i--);
}

inline static void  HOST_CMD_LOAD0(unsigned a, unsigned b, unsigned c, unsigned d)
{
	(*(volatile unsigned long *)(0x73500080+a*4))=c; 
 4e0:	e59f21b4 	ldr	r2, [pc, #436]	; 69c <InitRoutine_Start+0x69c>
 4e4:	e5832088 	str	r2, [r3, #136]	; 0x88
	(*(volatile unsigned long *)(0x735000C0+a*4))=((max(d,1)-1)<<12)|b;
 4e8:	e3a02c13 	mov	r2, #4864	; 0x1300
 4ec:	e58320c8 	str	r2, [r3, #200]	; 0xc8
	i=3200; while(i--);
}

inline static void  HOST_CMD_LOAD0(unsigned a, unsigned b, unsigned c, unsigned d)
{
	(*(volatile unsigned long *)(0x73500080+a*4))=c; 
 4f0:	e59f21a8 	ldr	r2, [pc, #424]	; 6a0 <InitRoutine_Start+0x6a0>
 4f4:	e583208c 	str	r2, [r3, #140]	; 0x8c
	(*(volatile unsigned long *)(0x735000C0+a*4))=((max(d,1)-1)<<12)|b;
 4f8:	e3a02c61 	mov	r2, #24832	; 0x6100
 4fc:	e58320cc 	str	r2, [r3, #204]	; 0xcc
	i=3200; while(i--);
}

inline static void  HOST_CMD_LOAD0(unsigned a, unsigned b, unsigned c, unsigned d)
{
	(*(volatile unsigned long *)(0x73500080+a*4))=c; 
 500:	e59f219c 	ldr	r2, [pc, #412]	; 6a4 <InitRoutine_Start+0x6a4>
 504:	e5832090 	str	r2, [r3, #144]	; 0x90
	(*(volatile unsigned long *)(0x735000C0+a*4))=((max(d,1)-1)<<12)|b;
 508:	e306201f 	movw	r2, #24607	; 0x601f
 50c:	e58320d0 	str	r2, [r3, #208]	; 0xd0
	i=3200; while(i--);
}

inline static void  HOST_CMD_LOAD0(unsigned a, unsigned b, unsigned c, unsigned d)
{
	(*(volatile unsigned long *)(0x73500080+a*4))=c; 
 510:	e59f2190 	ldr	r2, [pc, #400]	; 6a8 <InitRoutine_Start+0x6a8>
 514:	e5832094 	str	r2, [r3, #148]	; 0x94
	(*(volatile unsigned long *)(0x735000C0+a*4))=((max(d,1)-1)<<12)|b;
 518:	e59f218c 	ldr	r2, [pc, #396]	; 6ac <InitRoutine_Start+0x6ac>
 51c:	e58320d4 	str	r2, [r3, #212]	; 0xd4
	HOST_CMD_LOAD0(4, 0x000|((ret_mr0(round_up(DDR3_tWR_ps, tCK),1,nCL)&0xFF00)>>8),((ret_mr0(round_up(DDR3_tWR_ps, tCK),1,nCL)&0x00FF)<<24)|CMD_MRS, round_up(max(DDR3_tMOD_ps, DDR3_tMOD_ck*tCK), wait_cycle));

	//ZQCL
	HOST_CMD_LOAD0(5, 0x004, CMD_ZQC, round_up(DDR3_tZQINIT_ck*tCK, wait_cycle));

	dmc0_ctl(0x12) = 0x15; // HOST_CMD_ISSUE
 520:	e3a02015 	mov	r2, #21
 524:	e5832048 	str	r2, [r3, #72]	; 0x48
//	while(dmc0_ctl(0x12)&0x10); //

	dmc0_ctl(0x4) = 0x3; // MEM_START	
 528:	e3a02003 	mov	r2, #3
 52c:	e5832010 	str	r2, [r3, #16]
	        
// bit leveling and scl
	dmc0_phy(0x53) = 0xf; // WRLVL_AUTOINC_TRIM
 530:	e3a0200f 	mov	r2, #15
 534:	e59f30fc 	ldr	r3, [pc, #252]	; 638 <InitRoutine_Start+0x638>
 538:	e1a01003 	mov	r1, r3
 53c:	e583214c 	str	r2, [r3, #332]	; 0x14c
	dmc0_phy(0x4D) = 1<<16; //PHY_DLL_TRIM_2
 540:	e3a02801 	mov	r2, #65536	; 0x10000
 544:	e5832134 	str	r2, [r3, #308]	; 0x134
	dmc0_phy(0x40) = (1<<30)|(1<<28);  // SCL_START
 548:	e3a02205 	mov	r2, #1342177280	; 0x50000000
 54c:	e5832100 	str	r2, [r3, #256]	; 0x100
	while(dmc0_phy(0x40)&0x10000000); // wait bit clear
 550:	e5912100 	ldr	r2, [r1, #256]	; 0x100
 554:	e59f30dc 	ldr	r3, [pc, #220]	; 638 <InitRoutine_Start+0x638>
 558:	e2122201 	ands	r2, r2, #268435456	; 0x10000000
 55c:	1afffffb 	bne	550 <InitRoutine_Start+0x550>

	// Enable gating for bit-leveling
	dmc0_phy(0x6E) = 0x0; // DISABLE_GATING_FOR_SCL
 560:	e58321b8 	str	r2, [r3, #440]	; 0x1b8
	// write in bit levelling data
	dmc0_phy(0x41) = 0xFF00FF00; // SCL_DATA_0
 564:	e59f2144 	ldr	r2, [pc, #324]	; 6b0 <InitRoutine_Start+0x6b0>
 568:	e5832104 	str	r2, [r3, #260]	; 0x104
	dmc0_phy(0x42) = 0xFF00FF00; // SCL_DATA_1
 56c:	e5832108 	str	r2, [r3, #264]	; 0x108
	dmc0_phy(0x62) = 0x00080000; // PHY_SCL_START_ADDR
 570:	e3a02702 	mov	r2, #524288	; 0x80000
 574:	e5832188 	str	r2, [r3, #392]	; 0x188
	dmc0_phy(0x40) = 0x11000000; // SCL_START
 578:	e3a02411 	mov	r2, #285212672	; 0x11000000
 57c:	e5832100 	str	r2, [r3, #256]	; 0x100
	while(dmc0_phy(0x40)&0x10000000); // wait bit clear
 580:	e5932100 	ldr	r2, [r3, #256]	; 0x100
 584:	e2121201 	ands	r1, r2, #268435456	; 0x10000000
 588:	e59f20a8 	ldr	r2, [pc, #168]	; 638 <InitRoutine_Start+0x638>
 58c:	1afffffb 	bne	580 <InitRoutine_Start+0x580>

	// load SCL data into PHY
	dmc0_phy(0x62) = 0x00000000; // PHY_SCL_START_ADDR
	dmc0_phy(0x41) = 0x789b3de0; // SCL_DATA_0
 590:	e59f311c 	ldr	r3, [pc, #284]	; 6b4 <InitRoutine_Start+0x6b4>
	dmc0_phy(0x62) = 0x00080000; // PHY_SCL_START_ADDR
	dmc0_phy(0x40) = 0x11000000; // SCL_START
	while(dmc0_phy(0x40)&0x10000000); // wait bit clear

	// load SCL data into PHY
	dmc0_phy(0x62) = 0x00000000; // PHY_SCL_START_ADDR
 594:	e5821188 	str	r1, [r2, #392]	; 0x188
	dmc0_phy(0x41) = 0x789b3de0; // SCL_DATA_0
 598:	e5823104 	str	r3, [r2, #260]	; 0x104
	dmc0_phy(0x42) = 0xf10e4a56; // SCL_DATA_1
 59c:	e59f3114 	ldr	r3, [pc, #276]	; 6b8 <InitRoutine_Start+0x6b8>
 5a0:	e5823108 	str	r3, [r2, #264]	; 0x108

	// Run bit leveling
	dmc0_phy(0x40) = 0x30400000; //SCL_START
 5a4:	e3a035c1 	mov	r3, #809500672	; 0x30400000
 5a8:	e5823100 	str	r3, [r2, #256]	; 0x100
	while(dmc0_phy(0x40)&0x10000000); // wait bit clear
 5ac:	e5921100 	ldr	r1, [r2, #256]	; 0x100
 5b0:	e59f3080 	ldr	r3, [pc, #128]	; 638 <InitRoutine_Start+0x638>
 5b4:	e3110201 	tst	r1, #268435456	; 0x10000000
 5b8:	1afffffb 	bne	5ac <InitRoutine_Start+0x5ac>

	// Disable gating for bit-leveling to allow proper SCL gating
	dmc0_phy(0x6E) = 0x01; // DISABLE_GATING_FOR_SCL
 5bc:	e3a02001 	mov	r2, #1
 5c0:	e58321b8 	str	r2, [r3, #440]	; 0x1b8
#if defined PREVENT_DIGITAL_DLL_FOR_RECALIBRATION
	{
	    unsigned tmp;
	    tmp = dmc0_phy(0x49);
 5c4:	e5932124 	ldr	r2, [r3, #292]	; 0x124
	    tmp |= (1<<26);
 5c8:	e3822301 	orr	r2, r2, #67108864	; 0x4000000
	    dmc0_phy(0x49) = tmp;
 5cc:	e5832124 	str	r2, [r3, #292]	; 0x124
	}
#endif
	// Write SCL data int DRAM
	dmc0_phy(0x40) = 0x11000000; // SCL_START
 5d0:	e3a02411 	mov	r2, #285212672	; 0x11000000
 5d4:	e5832100 	str	r2, [r3, #256]	; 0x100
	while(dmc0_phy(0x40)&0x10000000); // wait bit clear
 5d8:	e5932100 	ldr	r2, [r3, #256]	; 0x100
 5dc:	e3120201 	tst	r2, #268435456	; 0x10000000
 5e0:	e59f2050 	ldr	r2, [pc, #80]	; 638 <InitRoutine_Start+0x638>
 5e4:	1afffffb 	bne	5d8 <InitRoutine_Start+0x5d8>

	// Run SCL
	dmc0_phy(0x50) = 0x10; // SCL_MAIN_CLK_DELTA
 5e8:	e3a03010 	mov	r3, #16
 5ec:	e5823140 	str	r3, [r2, #320]	; 0x140
	dmc0_phy(0x40) = 0x34000000; // SCL_START
 5f0:	e3a0330d 	mov	r3, #872415232	; 0x34000000
 5f4:	e5823100 	str	r3, [r2, #256]	; 0x100
	while(dmc0_phy(0x40)&0x10000000); // wait bit clear
 5f8:	e5923100 	ldr	r3, [r2, #256]	; 0x100
 5fc:	e2133201 	ands	r3, r3, #268435456	; 0x10000000
 600:	1afffffc 	bne	5f8 <InitRoutine_Start+0x5f8>
	// Turn off x-prop fix in simulation
	dmc0_phy(0x6E) = 0x03; // DISABLE_GATING_FOR_SCL
 604:	e59f202c 	ldr	r2, [pc, #44]	; 638 <InitRoutine_Start+0x638>
 608:	e3a01003 	mov	r1, #3
 60c:	e58211b8 	str	r1, [r2, #440]	; 0x1b8
#else
	#error "not selected ddr type.."
#endif
//	while(1);
	/* clear t32 debug check area (in SRAM) */
	*(volatile unsigned *)0x10008000 = 0;
 610:	e59f20a4 	ldr	r2, [pc, #164]	; 6bc <InitRoutine_Start+0x6bc>
 614:	e5823000 	str	r3, [r2]

}
 618:	e28dd00c 	add	sp, sp, #12
 61c:	e8bd8030 	pop	{r4, r5, pc}
 620:	00200014 	.word	0x00200014
 624:	74400000 	.word	0x74400000
 628:	04021681 	.word	0x04021681
 62c:	0601e90c 	.word	0x0601e90c
 630:	04034403 	.word	0x04034403
 634:	00200012 	.word	0x00200012
 638:	73880000 	.word	0x73880000
 63c:	50ff40f4 	.word	0x50ff40f4
 640:	a0001000 	.word	0xa0001000
 644:	01000075 	.word	0x01000075
 648:	02000501 	.word	0x02000501
 64c:	02200020 	.word	0x02200020
 650:	000251c0 	.word	0x000251c0
 654:	00c60046 	.word	0x00c60046
 658:	a0001004 	.word	0xa0001004
 65c:	73500000 	.word	0x73500000
 660:	00190a0d 	.word	0x00190a0d
 664:	00030002 	.word	0x00030002
 668:	000a03f8 	.word	0x000a03f8
 66c:	000113f0 	.word	0x000113f0
 670:	18780e35 	.word	0x18780e35
 674:	d62131ab 	.word	0xd62131ab
 678:	0022fe03 	.word	0x0022fe03
 67c:	a662e307 	.word	0xa662e307
 680:	7f10160f 	.word	0x7f10160f
 684:	ff000002 	.word	0xff000002
 688:	00030001 	.word	0x00030001
 68c:	00251100 	.word	0x00251100
 690:	73020002 	.word	0x73020002
 694:	00ffeffe 	.word	0x00ffeffe
 698:	20fff001 	.word	0x20fff001
 69c:	00fff001 	.word	0x00fff001
 6a0:	46fff001 	.word	0x46fff001
 6a4:	14fff001 	.word	0x14fff001
 6a8:	00fff601 	.word	0x00fff601
 6ac:	000ff004 	.word	0x000ff004
 6b0:	ff00ff00 	.word	0xff00ff00
 6b4:	789b3de0 	.word	0x789b3de0
 6b8:	f10e4a56 	.word	0xf10e4a56
 6bc:	10008000 	.word	0x10008000

Disassembly of section .text.InitRoutine_End:

00000000 <InitRoutine_End>:
* FUNCTION :void InitRoutine_End(void)
* DESCRIPTION :
* ***************************************************************************************/
//volatile void InitRoutine_End(void)
void InitRoutine_End(void)
{
   0:	e12fff1e 	bx	lr

Disassembly of section .text.copy_dram_param:

00000000 <copy_dram_param>:

/*===========================================================================
FUNCTION
===========================================================================*/
void copy_dram_param(void)
{
   0:	e12fff1e 	bx	lr

Disassembly of section .text.copy_dram_init:

00000000 <copy_dram_init>:
		*(volatile unsigned long *)(dest+i) = *(volatile unsigned long *)(src+i);

}
#else
void copy_dram_init(void)
{
   0:	e92d4008 	push	{r3, lr}
	memcpy((void*)SDRAM_INIT_FUNC_ADDR, (const void *)func_sdram_init, SDRAM_INIT_FUNC_SIZE);
   4:	e3a02c0d 	mov	r2, #3328	; 0xd00
   8:	e59f1028 	ldr	r1, [pc, #40]	; 38 <copy_dram_init+0x38>
   c:	e59f0028 	ldr	r0, [pc, #40]	; 3c <copy_dram_init+0x3c>
  10:	ebfffffe 	bl	0 <memcpy>
			10: R_ARM_CALL	memcpy
	memcpy((void*)SDRAM_SELF_REF_ENTER_ADDR, (const void *)ddr_self_refresh_enter, SDRAM_SELF_REF_ENTER_SIZE);
  14:	e59f1024 	ldr	r1, [pc, #36]	; 40 <copy_dram_init+0x40>
  18:	e3a02e1a 	mov	r2, #416	; 0x1a0
  1c:	e59f0020 	ldr	r0, [pc, #32]	; 44 <copy_dram_init+0x44>
  20:	ebfffffe 	bl	0 <memcpy>
			20: R_ARM_CALL	memcpy
	memcpy((void*)SDRAM_SELF_REF_EXIT_ADDR, (const void *)ddr_self_refresh_exit, SDRAM_SELF_REF_EXIT_SIZE);
  24:	e59f001c 	ldr	r0, [pc, #28]	; 48 <copy_dram_init+0x48>
  28:	e59f101c 	ldr	r1, [pc, #28]	; 4c <copy_dram_init+0x4c>
  2c:	e3a02e16 	mov	r2, #352	; 0x160
}
  30:	e8bd4008 	pop	{r3, lr}
#else
void copy_dram_init(void)
{
	memcpy((void*)SDRAM_INIT_FUNC_ADDR, (const void *)func_sdram_init, SDRAM_INIT_FUNC_SIZE);
	memcpy((void*)SDRAM_SELF_REF_ENTER_ADDR, (const void *)ddr_self_refresh_enter, SDRAM_SELF_REF_ENTER_SIZE);
	memcpy((void*)SDRAM_SELF_REF_EXIT_ADDR, (const void *)ddr_self_refresh_exit, SDRAM_SELF_REF_EXIT_SIZE);
  34:	eafffffe 	b	0 <memcpy>
			34: R_ARM_JUMP24	memcpy
  38:	00000000 	.word	0x00000000
			38: R_ARM_ABS32	func_sdram_init
  3c:	10000400 	.word	0x10000400
  40:	00000000 	.word	0x00000000
			40: R_ARM_ABS32	ddr_self_refresh_enter
  44:	10001100 	.word	0x10001100
  48:	100012a0 	.word	0x100012a0
  4c:	00000000 	.word	0x00000000
			4c: R_ARM_ABS32	ddr_self_refresh_exit

Disassembly of section .text.change_mem_clock:

00000000 <change_mem_clock>:
	FuncPtr pFunc = (FuncPtr)(CKC_CHANGE_FUNC_ADDR);

	//Bruce_temp_8920, memcpy .
	//memcpy((void *)CKC_CHANGE_FUNC_ADDR, (void*)_change_mem_clock, CKC_CHANGE_FUNC_SIZE);
	{
		unsigned src = (unsigned)_change_mem_clock;
   0:	e59fc6b8 	ldr	ip, [pc, #1720]	; 6c0 <change_mem_clock+0x6c0>
		unsigned dest = CKC_CHANGE_FUNC_ADDR;

		for(i=0;i<CKC_CHANGE_FUNC_SIZE;i+=4)
   4:	e3a03000 	mov	r3, #0

/*===========================================================================
FUNCTION
===========================================================================*/
int change_mem_clock(unsigned int freq)
{
   8:	e92d4df0 	push	{r4, r5, r6, r7, r8, sl, fp, lr}
   c:	e24dd050 	sub	sp, sp, #80	; 0x50
  10:	e2832201 	add	r2, r3, #268435456	; 0x10000000
	{
		unsigned src = (unsigned)_change_mem_clock;
		unsigned dest = CKC_CHANGE_FUNC_ADDR;

		for(i=0;i<CKC_CHANGE_FUNC_SIZE;i+=4)
			*(volatile unsigned long *)(dest+i) = *(volatile unsigned long *)(src+i);
  14:	e793100c 	ldr	r1, [r3, ip]
	//memcpy((void *)CKC_CHANGE_FUNC_ADDR, (void*)_change_mem_clock, CKC_CHANGE_FUNC_SIZE);
	{
		unsigned src = (unsigned)_change_mem_clock;
		unsigned dest = CKC_CHANGE_FUNC_ADDR;

		for(i=0;i<CKC_CHANGE_FUNC_SIZE;i+=4)
  18:	e2833004 	add	r3, r3, #4
  1c:	e2822a03 	add	r2, r2, #12288	; 0x3000
  20:	e3530a01 	cmp	r3, #4096	; 0x1000
			*(volatile unsigned long *)(dest+i) = *(volatile unsigned long *)(src+i);
  24:	e5821000 	str	r1, [r2]
	//memcpy((void *)CKC_CHANGE_FUNC_ADDR, (void*)_change_mem_clock, CKC_CHANGE_FUNC_SIZE);
	{
		unsigned src = (unsigned)_change_mem_clock;
		unsigned dest = CKC_CHANGE_FUNC_ADDR;

		for(i=0;i<CKC_CHANGE_FUNC_SIZE;i+=4)
  28:	1afffff8 	bne	10 <change_mem_clock+0x10>
{
	tPMS nPLL;
	//unsigned int tmp_src, tmp_div;
	unsigned temp;

	nPLL.fpll = mem_freq;
  2c:	e28d3050 	add	r3, sp, #80	; 0x50
	if (tcc_find_pms(&nPLL, XIN_CLK_RATE))
  30:	e59f168c 	ldr	r1, [pc, #1676]	; 6c4 <change_mem_clock+0x6c4>
{
	tPMS nPLL;
	//unsigned int tmp_src, tmp_div;
	unsigned temp;

	nPLL.fpll = mem_freq;
  34:	e5230018 	str	r0, [r3, #-24]!	; 0xffffffe8
	if (tcc_find_pms(&nPLL, XIN_CLK_RATE))
  38:	e1a00003 	mov	r0, r3
  3c:	ebfffffe 	bl	0 <tcc_find_pms>
			3c: R_ARM_CALL	tcc_find_pms
  40:	e3500000 	cmp	r0, #0
		return 0;
  44:	13a04000 	movne	r4, #0
	tPMS nPLL;
	//unsigned int tmp_src, tmp_div;
	unsigned temp;

	nPLL.fpll = mem_freq;
	if (tcc_find_pms(&nPLL, XIN_CLK_RATE))
  48:	1a00002a 	bne	f8 <change_mem_clock+0xf8>

	printf( "P = %d , M = %d , S = %d \n", nPLL.p , nPLL.m, nPLL.s);

	//tmp_src = 0;	// XIN
	//tmp_div = 0xFF;	// 
	CKC_CHANGE_ARG(CKC_CTRL_VALUE) = 0x00001F08;//0x00000008|(tmp_src&0x7)|((tmp_div<<8)&0xFF000);
  4c:	e59f4674 	ldr	r4, [pc, #1652]	; 6c8 <change_mem_clock+0x6c8>

	nPLL.fpll = mem_freq;
	if (tcc_find_pms(&nPLL, XIN_CLK_RATE))
		return 0;

	printf( "P = %d , M = %d , S = %d \n", nPLL.p , nPLL.m, nPLL.s);
  50:	e28d1040 	add	r1, sp, #64	; 0x40
  54:	e59f0670 	ldr	r0, [pc, #1648]	; 6cc <change_mem_clock+0x6cc>
  58:	e891000e 	ldm	r1, {r1, r2, r3}
  5c:	ebfffffe 	bl	0 <printf>
			5c: R_ARM_CALL	printf

	//tmp_src = 0;	// XIN
	//tmp_div = 0xFF;	// 
	CKC_CHANGE_ARG(CKC_CTRL_VALUE) = 0x00001F08;//0x00000008|(tmp_src&0x7)|((tmp_div<<8)&0xFF000);
  60:	e3011f08 	movw	r1, #7944	; 0x1f08
	temp = 0x00001F08;
	printf( "CKC_CTRL_VALUE = %8x\n", temp);
  64:	e59f0664 	ldr	r0, [pc, #1636]	; 6d0 <change_mem_clock+0x6d0>

	printf( "P = %d , M = %d , S = %d \n", nPLL.p , nPLL.m, nPLL.s);

	//tmp_src = 0;	// XIN
	//tmp_div = 0xFF;	// 
	CKC_CHANGE_ARG(CKC_CTRL_VALUE) = 0x00001F08;//0x00000008|(tmp_src&0x7)|((tmp_div<<8)&0xFF000);
  68:	e5841004 	str	r1, [r4, #4]
	temp = 0x00001F08;
	printf( "CKC_CTRL_VALUE = %8x\n", temp);
  6c:	ebfffffe 	bl	0 <printf>
			6c: R_ARM_CALL	printf
	CKC_CHANGE_ARG(PLL_VALUE) =  ((nPLL.s&0x7) << 16 ) | (1 << 26) | (0 << 19) | ((nPLL.m&0x3FF) << 6) | (nPLL.p&0x3F);
  70:	e59d2040 	ldr	r2, [sp, #64]	; 0x40
  74:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
  78:	e202203f 	and	r2, r2, #63	; 0x3f
	temp = ((nPLL.s&0x7) << 16 ) | (1 << 26) | (0 << 19) | ((nPLL.m&0x3FF) << 6) | (nPLL.p&0x3F);
	printf( "PLL = %8x\n", temp);
  7c:	e59f0650 	ldr	r0, [pc, #1616]	; 6d4 <change_mem_clock+0x6d4>
	//tmp_src = 0;	// XIN
	//tmp_div = 0xFF;	// 
	CKC_CHANGE_ARG(CKC_CTRL_VALUE) = 0x00001F08;//0x00000008|(tmp_src&0x7)|((tmp_div<<8)&0xFF000);
	temp = 0x00001F08;
	printf( "CKC_CTRL_VALUE = %8x\n", temp);
	CKC_CHANGE_ARG(PLL_VALUE) =  ((nPLL.s&0x7) << 16 ) | (1 << 26) | (0 << 19) | ((nPLL.m&0x3FF) << 6) | (nPLL.p&0x3F);
  80:	e2033007 	and	r3, r3, #7
  84:	e3822301 	orr	r2, r2, #67108864	; 0x4000000
  88:	e1823803 	orr	r3, r2, r3, lsl #16
  8c:	e59d2044 	ldr	r2, [sp, #68]	; 0x44
  90:	e1a02302 	lsl	r2, r2, #6
  94:	e6ff2072 	uxth	r2, r2
  98:	e1833002 	orr	r3, r3, r2
  9c:	e5843000 	str	r3, [r4]
	temp = ((nPLL.s&0x7) << 16 ) | (1 << 26) | (0 << 19) | ((nPLL.m&0x3FF) << 6) | (nPLL.p&0x3F);
  a0:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
  a4:	e59d1048 	ldr	r1, [sp, #72]	; 0x48
  a8:	e203303f 	and	r3, r3, #63	; 0x3f
  ac:	e2011007 	and	r1, r1, #7
  b0:	e3833301 	orr	r3, r3, #67108864	; 0x4000000
  b4:	e1831801 	orr	r1, r3, r1, lsl #16
  b8:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
  bc:	e1a03303 	lsl	r3, r3, #6
  c0:	e6ff3073 	uxth	r3, r3
	printf( "PLL = %8x\n", temp);
  c4:	e1811003 	orr	r1, r1, r3
  c8:	ebfffffe 	bl	0 <printf>
			c8: R_ARM_CALL	printf
	CKC_CHANGE_ARG(CLK_RATE) = (nPLL.fpll/1000000);
  cc:	e59d0038 	ldr	r0, [sp, #56]	; 0x38
  d0:	e59f1600 	ldr	r1, [pc, #1536]	; 6d8 <change_mem_clock+0x6d8>
  d4:	ebfffffe 	bl	0 <__aeabi_uidiv>
			d4: R_ARM_CALL	__aeabi_uidiv
	temp = (nPLL.fpll/1000000);
  d8:	e59f15f8 	ldr	r1, [pc, #1528]	; 6d8 <change_mem_clock+0x6d8>
	temp = 0x00001F08;
	printf( "CKC_CTRL_VALUE = %8x\n", temp);
	CKC_CHANGE_ARG(PLL_VALUE) =  ((nPLL.s&0x7) << 16 ) | (1 << 26) | (0 << 19) | ((nPLL.m&0x3FF) << 6) | (nPLL.p&0x3F);
	temp = ((nPLL.s&0x7) << 16 ) | (1 << 26) | (0 << 19) | ((nPLL.m&0x3FF) << 6) | (nPLL.p&0x3F);
	printf( "PLL = %8x\n", temp);
	CKC_CHANGE_ARG(CLK_RATE) = (nPLL.fpll/1000000);
  dc:	e5840008 	str	r0, [r4, #8]
	temp = (nPLL.fpll/1000000);
  e0:	e59d0038 	ldr	r0, [sp, #56]	; 0x38
  e4:	ebfffffe 	bl	0 <__aeabi_uidiv>
			e4: R_ARM_CALL	__aeabi_uidiv
  e8:	e1a01000 	mov	r1, r0
	printf( "CLK_RATE = %8x\n", temp);
  ec:	e59f05e8 	ldr	r0, [pc, #1512]	; 6dc <change_mem_clock+0x6dc>
  f0:	ebfffffe 	bl	0 <printf>
			f0: R_ARM_CALL	printf

	return CKC_CHANGE_ARG(CLK_RATE);
  f4:	e5944008 	ldr	r4, [r4, #8]
		for(i=0;i<CKC_CHANGE_FUNC_SIZE;i+=4)
			*(volatile unsigned long *)(dest+i) = *(volatile unsigned long *)(src+i);
	}

	mem_freq = get_membus_ckc(freq);
	printf("MEM FREQ: %dMHz\n", mem_freq);
  f8:	e1a01004 	mov	r1, r4
  fc:	e59f05dc 	ldr	r0, [pc, #1500]	; 6e0 <change_mem_clock+0x6e0>
 100:	ebfffffe 	bl	0 <printf>
			100: R_ARM_CALL	printf
	unsigned nCL = 0;
	unsigned nCWL = 0;
	//signed tmp = 0;
	unsigned wait_cycle;

	tck = (1000000/mem_freq);
 104:	e59f05cc 	ldr	r0, [pc, #1484]	; 6d8 <change_mem_clock+0x6d8>
 108:	e1a01004 	mov	r1, r4
 10c:	ebfffffe 	bl	0 <__aeabi_uidiv>
			10c: R_ARM_CALL	__aeabi_uidiv

	if(tck >= 2500){ /* 2.5ns, 400MHz */
		nCL = 9;
		nCWL = 6;
	}else if(tck >= 1875){ // 1.875ns, 533..MHz
 110:	e3003752 	movw	r3, #1874	; 0x752
 114:	e1500003 	cmp	r0, r3
	unsigned nCL = 0;
	unsigned nCWL = 0;
	//signed tmp = 0;
	unsigned wait_cycle;

	tck = (1000000/mem_freq);
 118:	e1a06000 	mov	r6, r0
	if(tck >= 2500){ /* 2.5ns, 400MHz */
		nCL = 9;
		nCWL = 6;
	}else if(tck >= 1875){ // 1.875ns, 533..MHz
		nCL = 9;
		nCWL = 6;
 11c:	83a07006 	movhi	r7, #6

	if(tck >= 2500){ /* 2.5ns, 400MHz */
		nCL = 9;
		nCWL = 6;
	}else if(tck >= 1875){ // 1.875ns, 533..MHz
		nCL = 9;
 120:	83a05009 	movhi	r5, #9
	tck = (1000000/mem_freq);

	if(tck >= 2500){ /* 2.5ns, 400MHz */
		nCL = 9;
		nCWL = 6;
	}else if(tck >= 1875){ // 1.875ns, 533..MHz
 124:	8a000014 	bhi	17c <change_mem_clock+0x17c>
		nCL = 9;
		nCWL = 6;
	}else if(tck >= 1500){ // 1.5 ns, 666..MHz
 128:	e30035db 	movw	r3, #1499	; 0x5db
 12c:	e1500003 	cmp	r0, r3
#if defined(CONFIG_DDR3_1600)
			nCL = 9;
#else
			nCL = 10;
#endif
		nCWL = 7;
 130:	83a07007 	movhi	r7, #7
		nCWL = 6;
	}else if(tck >= 1500){ // 1.5 ns, 666..MHz
#if defined(CONFIG_DDR3_1600)
			nCL = 9;
#else
			nCL = 10;
 134:	83a0500a 	movhi	r5, #10
		nCL = 9;
		nCWL = 6;
	}else if(tck >= 1875){ // 1.875ns, 533..MHz
		nCL = 9;
		nCWL = 6;
	}else if(tck >= 1500){ // 1.5 ns, 666..MHz
 138:	8a00000f 	bhi	17c <change_mem_clock+0x17c>
			nCL = 9;
#else
			nCL = 10;
#endif
		nCWL = 7;
	}else if(tck >= 1250){ // 1.25 ns, 800MHz
 13c:	e30034e1 	movw	r3, #1249	; 0x4e1
 140:	e1500003 	cmp	r0, r3
		nCL = 11;
		nCWL = 8;
 144:	83a07008 	movhi	r7, #8
#else
			nCL = 10;
#endif
		nCWL = 7;
	}else if(tck >= 1250){ // 1.25 ns, 800MHz
		nCL = 11;
 148:	83a0500b 	movhi	r5, #11
			nCL = 9;
#else
			nCL = 10;
#endif
		nCWL = 7;
	}else if(tck >= 1250){ // 1.25 ns, 800MHz
 14c:	8a00000a 	bhi	17c <change_mem_clock+0x17c>
		nCL = 11;
		nCWL = 8;
	}else if(tck >= 1070){ // 1.07 ns, 933..MHz
 150:	e300342d 	movw	r3, #1069	; 0x42d
 154:	e1500003 	cmp	r0, r3
		nCL = 13;
		nCWL = 9;
 158:	83a07009 	movhi	r7, #9
		nCWL = 7;
	}else if(tck >= 1250){ // 1.25 ns, 800MHz
		nCL = 11;
		nCWL = 8;
	}else if(tck >= 1070){ // 1.07 ns, 933..MHz
		nCL = 13;
 15c:	83a0500d 	movhi	r5, #13
#endif
		nCWL = 7;
	}else if(tck >= 1250){ // 1.25 ns, 800MHz
		nCL = 11;
		nCWL = 8;
	}else if(tck >= 1070){ // 1.07 ns, 933..MHz
 160:	8a000005 	bhi	17c <change_mem_clock+0x17c>
		nCL = 13;
		nCWL = 9;
	}else if(tck >= 935){ // 0.935 ns, 1066..MHz
 164:	e30033a6 	movw	r3, #934	; 0x3a6
 168:	e1500003 	cmp	r0, r3
{
#if defined(DRAM_DDR3)

	unsigned tck = 0;
	unsigned nCL = 0;
	unsigned nCWL = 0;
 16c:	93a07000 	movls	r7, #0
static void get_ddr_param(unsigned int mem_freq)
{
#if defined(DRAM_DDR3)

	unsigned tck = 0;
	unsigned nCL = 0;
 170:	91a05007 	movls	r5, r7
	}else if(tck >= 1070){ // 1.07 ns, 933..MHz
		nCL = 13;
		nCWL = 9;
	}else if(tck >= 935){ // 0.935 ns, 1066..MHz
		nCL = 14;
		nCWL = 10;
 174:	83a0700a 	movhi	r7, #10
		nCWL = 8;
	}else if(tck >= 1070){ // 1.07 ns, 933..MHz
		nCL = 13;
		nCWL = 9;
	}else if(tck >= 935){ // 0.935 ns, 1066..MHz
		nCL = 14;
 178:	83a0500e 	movhi	r5, #14
		nCWL = 10;
	}

	wait_cycle = HALF_RATE_MODE ? 2*tck : tck;

	CKC_CHANGE_ARG(DMC_46H)= (1<<24)|(0<<16)|(0<<12)|(round_up(nCL,2)<<4)|(0<<3)|(1<<2)|(0<<1)|1;
 17c:	e2853001 	add	r3, r5, #1
	}else if(tck >= 935){ // 0.935 ns, 1066..MHz
		nCL = 14;
		nCWL = 10;
	}

	wait_cycle = HALF_RATE_MODE ? 2*tck : tck;
 180:	e1a04086 	lsl	r4, r6, #1
		      rd2wr_dly     = BL + 2 + round_down((nCL - nCWL), 2);
		      wr2wr_csc_dly = BL;
		      wr2wr_dly     = BL-1;
		      rd2rd_csc_dly = BL+1;
		      rd2rd_dly     = BL-1;
		      wr2rd_csc_dly = max((WL+BL) + max(round_up(DDR3_tWTR_ps, 2*tck), round_up(DDR3_tWTR_ck, 2)) - 1, 3);
 184:	e2840d75 	add	r0, r4, #7488	; 0x1d40
 188:	e284bdd9 	add	fp, r4, #13888	; 0x3640
		nCWL = 10;
	}

	wait_cycle = HALF_RATE_MODE ? 2*tck : tck;

	CKC_CHANGE_ARG(DMC_46H)= (1<<24)|(0<<16)|(0<<12)|(round_up(nCL,2)<<4)|(0<<3)|(1<<2)|(0<<1)|1;
 18c:	e1a030a3 	lsr	r3, r3, #1
 190:	e58d3008 	str	r3, [sp, #8]
		      rd2wr_dly     = BL + 2 + round_down((nCL - nCWL), 2);
		      wr2wr_csc_dly = BL;
		      wr2wr_dly     = BL-1;
		      rd2rd_csc_dly = BL+1;
		      rd2rd_dly     = BL-1;
		      wr2rd_csc_dly = max((WL+BL) + max(round_up(DDR3_tWTR_ps, 2*tck), round_up(DDR3_tWTR_ck, 2)) - 1, 3);
 194:	e280000b 	add	r0, r0, #11
 198:	e28bb015 	add	fp, fp, #21
		nCWL = 10;
	}

	wait_cycle = HALF_RATE_MODE ? 2*tck : tck;

	CKC_CHANGE_ARG(DMC_46H)= (1<<24)|(0<<16)|(0<<12)|(round_up(nCL,2)<<4)|(0<<3)|(1<<2)|(0<<1)|1;
 19c:	e1a02203 	lsl	r2, r3, #4
 1a0:	e59f3520 	ldr	r3, [pc, #1312]	; 6c8 <change_mem_clock+0x6c8>
 1a4:	e3822401 	orr	r2, r2, #16777216	; 0x1000000
 1a8:	e3822005 	orr	r2, r2, #5
 1ac:	e5832054 	str	r2, [r3, #84]	; 0x54
	// SCL_CONFIG_1
	// ddr_odt_ctl_wr, ddr_odt_ctrl_rd, local_odt_ctrl, rd_cas_latency, dly_dfi_phyupd_ack, ddr3, ddr2, burst8

	CKC_CHANGE_ARG(DMC_47H) = (SWAP_PHASE<<31)|(0<<30)|(0<<29)|(0<<28)|(1<<25)|((HALF_RATE_MODE && (((nCWL%2==0)?1:0)^SWAP_PHASE))<<24)|(0<<12)|(round_up(nCWL,2)<<8)|1;
 1b0:	e2172001 	ands	r2, r7, #1
 1b4:	e58d2010 	str	r2, [sp, #16]
 1b8:	e2872001 	add	r2, r7, #1
 1bc:	13a01402 	movne	r1, #33554432	; 0x2000000
 1c0:	03a01403 	moveq	r1, #50331648	; 0x3000000
 1c4:	e1a020a2 	lsr	r2, r2, #1
 1c8:	e1812402 	orr	r2, r1, r2, lsl #8
 1cc:	e3822001 	orr	r2, r2, #1
 1d0:	e5832058 	str	r2, [r3, #88]	; 0x58
	// SCL_CONFIG_2
	// swap_phase,rdfifo_enable,lpddr2,analog_dll_for_scl,scl_step,size,dly_dfi_wrdata,double_ref_dly,wr_cas,latency,scl_test_cs

	CKC_CHANGE_ARG(DMC_6FH) = ((nCWL%2==0) && SWAP_PHASE);
 1d4:	e3a02000 	mov	r2, #0
 1d8:	e5832060 	str	r2, [r3, #96]	; 0x60
	// SCL_CONFIG_4

	CKC_CHANGE_ARG(DMC_54H) = (((RTT_WR<<9)|((nCWL-5)<<3))<<16)|(((nCWL-5)<<3));
 1dc:	e2472005 	sub	r2, r7, #5
 1e0:	e58d2014 	str	r2, [sp, #20]
 1e4:	e1a02182 	lsl	r2, r2, #3
 1e8:	e3821c02 	orr	r1, r2, #512	; 0x200
 1ec:	e1822801 	orr	r2, r2, r1, lsl #16
 1f0:	e583205c 	str	r2, [r3, #92]	; 0x5c
		int tRCD, tXS, tXP, tCKE, tCKESR; 
		int RL, WL;	


		RL = HALF_RATE_MODE ? round_up (nCL, 2)        : nCL;
		WL = HALF_RATE_MODE ? round_up ((nCWL + 1), 2) : nCWL;
 1f4:	e2873002 	add	r3, r7, #2

		rmw_dly        = RL+C2D+MAX_LATENCY-WL+4+(ECC_DLY|HALF_RATE_SUPPORT ? 1 : 0);
 1f8:	e59d2008 	ldr	r2, [sp, #8]
		      rd2wr_dly     = BL + 2 + round_down((nCL - nCWL), 2);
		      wr2wr_csc_dly = BL;
		      wr2wr_dly     = BL-1;
		      rd2rd_csc_dly = BL+1;
		      rd2rd_dly     = BL-1;
		      wr2rd_csc_dly = max((WL+BL) + max(round_up(DDR3_tWTR_ps, 2*tck), round_up(DDR3_tWTR_ck, 2)) - 1, 3);
 1fc:	e1a01004 	mov	r1, r4
		int tRCD, tXS, tXP, tCKE, tCKESR; 
		int RL, WL;	


		RL = HALF_RATE_MODE ? round_up (nCL, 2)        : nCL;
		WL = HALF_RATE_MODE ? round_up ((nCWL + 1), 2) : nCWL;
 200:	e1a030a3 	lsr	r3, r3, #1
 204:	e58d300c 	str	r3, [sp, #12]

		rmw_dly        = RL+C2D+MAX_LATENCY-WL+4+(ECC_DLY|HALF_RATE_SUPPORT ? 1 : 0);
 208:	e0633002 	rsb	r3, r3, r2
 20c:	e283300b 	add	r3, r3, #11
 210:	e58d3030 	str	r3, [sp, #48]	; 0x30

		if (HALF_RATE_MODE)
		{
		      rd2wr_dly     = BL + 2 + round_down((nCL - nCWL), 2);
 214:	e0673005 	rsb	r3, r7, r5
 218:	e58d3018 	str	r3, [sp, #24]
 21c:	e1a030a3 	lsr	r3, r3, #1
 220:	e2833004 	add	r3, r3, #4
 224:	e58d3034 	str	r3, [sp, #52]	; 0x34
		      wr2wr_csc_dly = BL;
		      wr2wr_dly     = BL-1;
		      rd2rd_csc_dly = BL+1;
		      rd2rd_dly     = BL-1;
		      wr2rd_csc_dly = max((WL+BL) + max(round_up(DDR3_tWTR_ps, 2*tck), round_up(DDR3_tWTR_ck, 2)) - 1, 3);
 228:	ebfffffe 	bl	0 <__aeabi_uidiv>
			228: R_ARM_CALL	__aeabi_uidiv
 22c:	e59d200c 	ldr	r2, [sp, #12]
		      wr2rd_dly     = (WL+BL) + max(round_up(DDR3_tWTR_ps, 2*tck), round_up(DDR3_tWTR_ck, 2));
		      wr2prech_dly  = round_up(DDR3_tWR_ps, 2*tck) + (WL+BL);
 230:	e1a01004 	mov	r1, r4
		      rd2wr_dly     = BL + 2 + round_down((nCL - nCWL), 2);
		      wr2wr_csc_dly = BL;
		      wr2wr_dly     = BL-1;
		      rd2rd_csc_dly = BL+1;
		      rd2rd_dly     = BL-1;
		      wr2rd_csc_dly = max((WL+BL) + max(round_up(DDR3_tWTR_ps, 2*tck), round_up(DDR3_tWTR_ck, 2)) - 1, 3);
 234:	e3500002 	cmp	r0, #2
 238:	33a00002 	movcc	r0, #2
 23c:	e58d001c 	str	r0, [sp, #28]
 240:	e0823000 	add	r3, r2, r0
		      wr2rd_dly     = (WL+BL) + max(round_up(DDR3_tWTR_ps, 2*tck), round_up(DDR3_tWTR_ck, 2));
		      wr2prech_dly  = round_up(DDR3_tWR_ps, 2*tck) + (WL+BL);
 244:	e2840dea 	add	r0, r4, #14976	; 0x3a80
 248:	e2800017 	add	r0, r0, #23
		      rd2wr_dly     = BL + 2 + round_down((nCL - nCWL), 2);
		      wr2wr_csc_dly = BL;
		      wr2wr_dly     = BL-1;
		      rd2rd_csc_dly = BL+1;
		      rd2rd_dly     = BL-1;
		      wr2rd_csc_dly = max((WL+BL) + max(round_up(DDR3_tWTR_ps, 2*tck), round_up(DDR3_tWTR_ck, 2)) - 1, 3);
 24c:	e283a001 	add	sl, r3, #1
		      wr2rd_dly     = (WL+BL) + max(round_up(DDR3_tWTR_ps, 2*tck), round_up(DDR3_tWTR_ck, 2));
 250:	e2833002 	add	r3, r3, #2
 254:	e58d3020 	str	r3, [sp, #32]
		      wr2prech_dly  = round_up(DDR3_tWR_ps, 2*tck) + (WL+BL);
 258:	ebfffffe 	bl	0 <__aeabi_uidiv>
			258: R_ARM_CALL	__aeabi_uidiv
 25c:	e59d300c 	ldr	r3, [sp, #12]
		      wr2rd_dly     = (WL+BL) + max(round_up(DDR3_tWTR_ps, 2*tck), DDR3_tWTR_ck);
		      wr2prech_dly  = round_up(DDR3_tWR_ps, 2*tck) + (WL+max(BL,3)); 
	}	
		nxt_dt_av_dly = 0;		

		if ((round_up(DDR3_tRCD_ps, tck) % 2) == 0 && !SWAP_PHASE && HALF_RATE_MODE)
 260:	e1a01006 	mov	r1, r6
		      rd2wr_dly     = BL + 2 + round_down((nCL - nCWL), 2);
		      wr2wr_csc_dly = BL;
		      wr2wr_dly     = BL-1;
		      rd2rd_csc_dly = BL+1;
		      rd2rd_dly     = BL-1;
		      wr2rd_csc_dly = max((WL+BL) + max(round_up(DDR3_tWTR_ps, 2*tck), round_up(DDR3_tWTR_ck, 2)) - 1, 3);
 264:	e35a0003 	cmp	sl, #3
 268:	33a0a003 	movcc	sl, #3
		      wr2rd_dly     = (WL+BL) + max(round_up(DDR3_tWTR_ps, 2*tck), round_up(DDR3_tWTR_ck, 2));
		      wr2prech_dly  = round_up(DDR3_tWR_ps, 2*tck) + (WL+BL);
 26c:	e2800002 	add	r0, r0, #2
 270:	e0800003 	add	r0, r0, r3
 274:	e58d0024 	str	r0, [sp, #36]	; 0x24
		      wr2rd_dly     = (WL+BL) + max(round_up(DDR3_tWTR_ps, 2*tck), DDR3_tWTR_ck);
		      wr2prech_dly  = round_up(DDR3_tWR_ps, 2*tck) + (WL+max(BL,3)); 
	}	
		nxt_dt_av_dly = 0;		

		if ((round_up(DDR3_tRCD_ps, tck) % 2) == 0 && !SWAP_PHASE && HALF_RATE_MODE)
 278:	e2860dd9 	add	r0, r6, #13888	; 0x3640
 27c:	e2800015 	add	r0, r0, #21
 280:	ebfffffe 	bl	0 <__aeabi_uidiv>
			280: R_ARM_CALL	__aeabi_uidiv
		{
			tRCD = round_up(DDR3_tRCD_ps, 2*tck);
 284:	e1a01004 	mov	r1, r4
		      wr2rd_dly     = (WL+BL) + max(round_up(DDR3_tWTR_ps, 2*tck), DDR3_tWTR_ck);
		      wr2prech_dly  = round_up(DDR3_tWR_ps, 2*tck) + (WL+max(BL,3)); 
	}	
		nxt_dt_av_dly = 0;		

		if ((round_up(DDR3_tRCD_ps, tck) % 2) == 0 && !SWAP_PHASE && HALF_RATE_MODE)
 288:	e3100001 	tst	r0, #1
		{
			tRCD = round_up(DDR3_tRCD_ps, 2*tck);
 28c:	e1a0000b 	mov	r0, fp
		      wr2rd_dly     = (WL+BL) + max(round_up(DDR3_tWTR_ps, 2*tck), DDR3_tWTR_ck);
		      wr2prech_dly  = round_up(DDR3_tWR_ps, 2*tck) + (WL+max(BL,3)); 
	}	
		nxt_dt_av_dly = 0;		

		if ((round_up(DDR3_tRCD_ps, tck) % 2) == 0 && !SWAP_PHASE && HALF_RATE_MODE)
 290:	1a000001 	bne	29c <change_mem_clock+0x29c>
		{
			tRCD = round_up(DDR3_tRCD_ps, 2*tck);
 294:	ebfffffe 	bl	0 <__aeabi_uidiv>
			294: R_ARM_CALL	__aeabi_uidiv
 298:	ea000001 	b	2a4 <change_mem_clock+0x2a4>
	}
		else
		{
			tRCD = round_up(DDR3_tRCD_ps, 2*tck) - 1;
 29c:	ebfffffe 	bl	0 <__aeabi_uidiv>
			29c: R_ARM_CALL	__aeabi_uidiv
 2a0:	e2400001 	sub	r0, r0, #1
 2a4:	e58d0028 	str	r0, [sp, #40]	; 0x28
	}

		tXS       = AUTO_ZQC_ENABLE ? max(5, round_up((DDR3_tRFC_ps+10000), 2*tck)) : 0;
		tCKE      = max(DDR3_tCKE_ck, round_up(DDR3_tCKE_ps, 2*tck));
 2a8:	e2840d4e 	add	r0, r4, #4992	; 0x1380
 2ac:	e1a01004 	mov	r1, r4
 2b0:	e2800007 	add	r0, r0, #7
 2b4:	ebfffffe 	bl	0 <__aeabi_uidiv>
			2b4: R_ARM_CALL	__aeabi_uidiv
		tCKESR    = max(DDR3_tCKESR_ck, round_up(DDR3_tCKE_ps, 2*tck)+1);
		tXP       = max(max(DDR3_tXP_ck, round_up(DDR3_tXP_ps, 2*tck)), tCKE);
 2b8:	e1a01004 	mov	r1, r4
		{
			tRCD = round_up(DDR3_tRCD_ps, 2*tck) - 1;
	}

		tXS       = AUTO_ZQC_ENABLE ? max(5, round_up((DDR3_tRFC_ps+10000), 2*tck)) : 0;
		tCKE      = max(DDR3_tCKE_ck, round_up(DDR3_tCKE_ps, 2*tck));
 2bc:	e1a0c000 	mov	ip, r0
 2c0:	e3500003 	cmp	r0, #3
 2c4:	21a02000 	movcs	r2, r0
 2c8:	33a02003 	movcc	r2, #3
		tCKESR    = max(DDR3_tCKESR_ck, round_up(DDR3_tCKE_ps, 2*tck)+1);
		tXP       = max(max(DDR3_tXP_ck, round_up(DDR3_tXP_ps, 2*tck)), tCKE);
 2cc:	e2840d5d 	add	r0, r4, #5952	; 0x1740
 2d0:	e58d2004 	str	r2, [sp, #4]
 2d4:	e280002f 	add	r0, r0, #47	; 0x2f
 2d8:	e58dc000 	str	ip, [sp]
 2dc:	ebfffffe 	bl	0 <__aeabi_uidiv>
			2dc: R_ARM_CALL	__aeabi_uidiv
		sref_exit = HALF_RATE_MODE ? max(round_up(DDR3_tDLLK_ck, 2) - tXS, round_up(DDR3_tZQOPER_ck, 2))-2 :
		                               max(DDR3_tDLLK_ck               -tXS, DDR3_tZQOPER_ck             )-2 ;

		
		CKC_CHANGE_ARG(DMC_AH) = (1<<28)|(8<<24)|((round_up(DDR3_tRFC_ps, 2*tck)-2)<<16)|(round_up(DDR3_tREFI_ps, 2*tck)-2);
 2e0:	e1a01004 	mov	r1, r4
	}

		tXS       = AUTO_ZQC_ENABLE ? max(5, round_up((DDR3_tRFC_ps+10000), 2*tck)) : 0;
		tCKE      = max(DDR3_tCKE_ck, round_up(DDR3_tCKE_ps, 2*tck));
		tCKESR    = max(DDR3_tCKESR_ck, round_up(DDR3_tCKE_ps, 2*tck)+1);
		tXP       = max(max(DDR3_tXP_ck, round_up(DDR3_tXP_ps, 2*tck)), tCKE);
 2e4:	e58d002c 	str	r0, [sp, #44]	; 0x2c
		sref_exit = HALF_RATE_MODE ? max(round_up(DDR3_tDLLK_ck, 2) - tXS, round_up(DDR3_tZQOPER_ck, 2))-2 :
		                               max(DDR3_tDLLK_ck               -tXS, DDR3_tZQOPER_ck             )-2 ;

		
		CKC_CHANGE_ARG(DMC_AH) = (1<<28)|(8<<24)|((round_up(DDR3_tRFC_ps, 2*tck)-2)<<16)|(round_up(DDR3_tREFI_ps, 2*tck)-2);
 2e8:	e59f03f4 	ldr	r0, [pc, #1012]	; 6e4 <change_mem_clock+0x6e4>
 2ec:	e0840000 	add	r0, r4, r0
 2f0:	ebfffffe 	bl	0 <__aeabi_uidiv>
			2f0: R_ARM_CALL	__aeabi_uidiv
 2f4:	e1a01004 	mov	r1, r4
 2f8:	e2400002 	sub	r0, r0, #2
 2fc:	e3808306 	orr	r8, r0, #402653184	; 0x18000000
 300:	e59f03e0 	ldr	r0, [pc, #992]	; 6e8 <change_mem_clock+0x6e8>
 304:	e0840000 	add	r0, r4, r0
 308:	ebfffffe 	bl	0 <__aeabi_uidiv>
			308: R_ARM_CALL	__aeabi_uidiv
		//REF_CONFIG

		CKC_CHANGE_ARG(DMC_CH) = (rmw_dly<<28)|(rd2wr_dly<<24)|(wr2wr_csc_dly<<20)|(wr2wr_dly<<16)|(rd2rd_csc_dly<<12)|(rd2rd_dly<<8)|(wr2rd_csc_dly<<4)|wr2rd_dly;
 30c:	e59d3020 	ldr	r3, [sp, #32]
			tRCD = round_up(DDR3_tRCD_ps, 2*tck) - 1;
	}

		tXS       = AUTO_ZQC_ENABLE ? max(5, round_up((DDR3_tRFC_ps+10000), 2*tck)) : 0;
		tCKE      = max(DDR3_tCKE_ck, round_up(DDR3_tCKE_ps, 2*tck));
		tCKESR    = max(DDR3_tCKESR_ck, round_up(DDR3_tCKE_ps, 2*tck)+1);
 310:	e59dc000 	ldr	ip, [sp]
			                    (((nxt_dt_av_dly & (1<<4))>>4)<<29)|
			                    (((wr2rd_csc_dly & (1<<4))>>4)<<28)|
			                    (((wr2rd_dly & (1<<4))>>4)<<27)|
			                    (((wr2prech_dly & (1<<4))>>4)<<26)|
			                    (((tXP-1))<<20)|
			                    (((tCKE-1))<<16)|
 314:	e59d2004 	ldr	r2, [sp, #4]
			tRCD = round_up(DDR3_tRCD_ps, 2*tck) - 1;
	}

		tXS       = AUTO_ZQC_ENABLE ? max(5, round_up((DDR3_tRFC_ps+10000), 2*tck)) : 0;
		tCKE      = max(DDR3_tCKE_ck, round_up(DDR3_tCKE_ps, 2*tck));
		tCKESR    = max(DDR3_tCKESR_ck, round_up(DDR3_tCKE_ps, 2*tck)+1);
 318:	e28cc001 	add	ip, ip, #1
 31c:	e35c0004 	cmp	ip, #4
 320:	33a0c004 	movcc	ip, #4
			                    (((wr2rd_dly & (1<<4))>>4)<<27)|
			                    (((wr2prech_dly & (1<<4))>>4)<<26)|
			                    (((tXP-1))<<20)|
			                    (((tCKE-1))<<16)|
			                    (((sref_exit))<<8)|
			                    (((tCKESR-1)) <<0);
 324:	e24cc001 	sub	ip, ip, #1
		tXP       = max(max(DDR3_tXP_ck, round_up(DDR3_tXP_ps, 2*tck)), tCKE);
		sref_exit = HALF_RATE_MODE ? max(round_up(DDR3_tDLLK_ck, 2) - tXS, round_up(DDR3_tZQOPER_ck, 2))-2 :
		                               max(DDR3_tDLLK_ck               -tXS, DDR3_tZQOPER_ck             )-2 ;

		
		CKC_CHANGE_ARG(DMC_AH) = (1<<28)|(8<<24)|((round_up(DDR3_tRFC_ps, 2*tck)-2)<<16)|(round_up(DDR3_tREFI_ps, 2*tck)-2);
 328:	e2400002 	sub	r0, r0, #2
 32c:	e1880800 	orr	r0, r8, r0, lsl #16
 330:	e59f8390 	ldr	r8, [pc, #912]	; 6c8 <change_mem_clock+0x6c8>
 334:	e588000c 	str	r0, [r8, #12]
		//REF_CONFIG

		CKC_CHANGE_ARG(DMC_CH) = (rmw_dly<<28)|(rd2wr_dly<<24)|(wr2wr_csc_dly<<20)|(wr2wr_dly<<16)|(rd2rd_csc_dly<<12)|(rd2rd_dly<<8)|(wr2rd_csc_dly<<4)|wr2rd_dly;
 338:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
 33c:	e1831c00 	orr	r1, r3, r0, lsl #24
 340:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
 344:	e3811821 	orr	r1, r1, #2162688	; 0x210000
			                    (((tCKESR-1)) <<0);
		// DLY_CONFIG_2

		{
			unsigned rd_burst_end_dly = RL+3+(NATIVE_BURST8 ? 2:0);
			unsigned prech2ras_dly    = round_up(DDR3_tRP_ps, 2*tck)-1;
 348:	e1a0000b 	mov	r0, fp

		
		CKC_CHANGE_ARG(DMC_AH) = (1<<28)|(8<<24)|((round_up(DDR3_tRFC_ps, 2*tck)-2)<<16)|(round_up(DDR3_tREFI_ps, 2*tck)-2);
		//REF_CONFIG

		CKC_CHANGE_ARG(DMC_CH) = (rmw_dly<<28)|(rd2wr_dly<<24)|(wr2wr_csc_dly<<20)|(wr2wr_dly<<16)|(rd2rd_csc_dly<<12)|(rd2rd_dly<<8)|(wr2rd_csc_dly<<4)|wr2rd_dly;
 34c:	e3811c31 	orr	r1, r1, #12544	; 0x3100
 350:	e181120a 	orr	r1, r1, sl, lsl #4
		// DLY_CONFIG_1

		CKC_CHANGE_ARG(DMC_DH) = (((sref_exit & (1<<8))>>8)<<30)|
			                    (((nxt_dt_av_dly & (1<<4))>>4)<<29)|
			                    (((wr2rd_csc_dly & (1<<4))>>4)<<28)|
 354:	e7e0a25a 	ubfx	sl, sl, #4, #1

		
		CKC_CHANGE_ARG(DMC_AH) = (1<<28)|(8<<24)|((round_up(DDR3_tRFC_ps, 2*tck)-2)<<16)|(round_up(DDR3_tREFI_ps, 2*tck)-2);
		//REF_CONFIG

		CKC_CHANGE_ARG(DMC_CH) = (rmw_dly<<28)|(rd2wr_dly<<24)|(wr2wr_csc_dly<<20)|(wr2wr_dly<<16)|(rd2rd_csc_dly<<12)|(rd2rd_dly<<8)|(wr2rd_csc_dly<<4)|wr2rd_dly;
 358:	e1811e03 	orr	r1, r1, r3, lsl #28
 35c:	e5881010 	str	r1, [r8, #16]
			                    (((nxt_dt_av_dly & (1<<4))>>4)<<29)|
			                    (((wr2rd_csc_dly & (1<<4))>>4)<<28)|
			                    (((wr2rd_dly & (1<<4))>>4)<<27)|
			                    (((wr2prech_dly & (1<<4))>>4)<<26)|
			                    (((tXP-1))<<20)|
			                    (((tCKE-1))<<16)|
 360:	e2421001 	sub	r1, r2, #1

		CKC_CHANGE_ARG(DMC_DH) = (((sref_exit & (1<<8))>>8)<<30)|
			                    (((nxt_dt_av_dly & (1<<4))>>4)<<29)|
			                    (((wr2rd_csc_dly & (1<<4))>>4)<<28)|
			                    (((wr2rd_dly & (1<<4))>>4)<<27)|
			                    (((wr2prech_dly & (1<<4))>>4)<<26)|
 364:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
		CKC_CHANGE_ARG(DMC_CH) = (rmw_dly<<28)|(rd2wr_dly<<24)|(wr2wr_csc_dly<<20)|(wr2wr_dly<<16)|(rd2rd_csc_dly<<12)|(rd2rd_dly<<8)|(wr2rd_csc_dly<<4)|wr2rd_dly;
		// DLY_CONFIG_1

		CKC_CHANGE_ARG(DMC_DH) = (((sref_exit & (1<<8))>>8)<<30)|
			                    (((nxt_dt_av_dly & (1<<4))>>4)<<29)|
			                    (((wr2rd_csc_dly & (1<<4))>>4)<<28)|
 368:	e18cc801 	orr	ip, ip, r1, lsl #16
	}

		tXS       = AUTO_ZQC_ENABLE ? max(5, round_up((DDR3_tRFC_ps+10000), 2*tck)) : 0;
		tCKE      = max(DDR3_tCKE_ck, round_up(DDR3_tCKE_ps, 2*tck));
		tCKESR    = max(DDR3_tCKESR_ck, round_up(DDR3_tCKE_ps, 2*tck)+1);
		tXP       = max(max(DDR3_tXP_ck, round_up(DDR3_tXP_ps, 2*tck)), tCKE);
 36c:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
		// DLY_CONFIG_1

		CKC_CHANGE_ARG(DMC_DH) = (((sref_exit & (1<<8))>>8)<<30)|
			                    (((nxt_dt_av_dly & (1<<4))>>4)<<29)|
			                    (((wr2rd_csc_dly & (1<<4))>>4)<<28)|
			                    (((wr2rd_dly & (1<<4))>>4)<<27)|
 370:	e38cccfe 	orr	ip, ip, #65024	; 0xfe00
	}

		tXS       = AUTO_ZQC_ENABLE ? max(5, round_up((DDR3_tRFC_ps+10000), 2*tck)) : 0;
		tCKE      = max(DDR3_tCKE_ck, round_up(DDR3_tCKE_ps, 2*tck));
		tCKESR    = max(DDR3_tCKESR_ck, round_up(DDR3_tCKE_ps, 2*tck)+1);
		tXP       = max(max(DDR3_tXP_ck, round_up(DDR3_tXP_ps, 2*tck)), tCKE);
 374:	e3510003 	cmp	r1, #3
 378:	33a01003 	movcc	r1, #3
 37c:	e1510002 	cmp	r1, r2
 380:	21a02001 	movcs	r2, r1

		CKC_CHANGE_ARG(DMC_DH) = (((sref_exit & (1<<8))>>8)<<30)|
			                    (((nxt_dt_av_dly & (1<<4))>>4)<<29)|
			                    (((wr2rd_csc_dly & (1<<4))>>4)<<28)|
			                    (((wr2rd_dly & (1<<4))>>4)<<27)|
			                    (((wr2prech_dly & (1<<4))>>4)<<26)|
 384:	e7e01253 	ubfx	r1, r3, #4, #1
			                    (((tXP-1))<<20)|
 388:	e2422001 	sub	r2, r2, #1
		// DLY_CONFIG_1

		CKC_CHANGE_ARG(DMC_DH) = (((sref_exit & (1<<8))>>8)<<30)|
			                    (((nxt_dt_av_dly & (1<<4))>>4)<<29)|
			                    (((wr2rd_csc_dly & (1<<4))>>4)<<28)|
			                    (((wr2rd_dly & (1<<4))>>4)<<27)|
 38c:	e59d3020 	ldr	r3, [sp, #32]
			                    (((wr2prech_dly & (1<<4))>>4)<<26)|
 390:	e18c2a02 	orr	r2, ip, r2, lsl #20
			                    (((tXP-1))<<20)|
 394:	e1822d01 	orr	r2, r2, r1, lsl #26
		// DLY_CONFIG_1

		CKC_CHANGE_ARG(DMC_DH) = (((sref_exit & (1<<8))>>8)<<30)|
			                    (((nxt_dt_av_dly & (1<<4))>>4)<<29)|
			                    (((wr2rd_csc_dly & (1<<4))>>4)<<28)|
			                    (((wr2rd_dly & (1<<4))>>4)<<27)|
 398:	e7e01253 	ubfx	r1, r3, #4, #1
			                    (((wr2prech_dly & (1<<4))>>4)<<26)|
			                    (((tXP-1))<<20)|
			                    (((tCKE-1))<<16)|
 39c:	e1822d81 	orr	r2, r2, r1, lsl #27
			                    (((tCKESR-1)) <<0);
		// DLY_CONFIG_2

		{
			unsigned rd_burst_end_dly = RL+3+(NATIVE_BURST8 ? 2:0);
			unsigned prech2ras_dly    = round_up(DDR3_tRP_ps, 2*tck)-1;
 3a0:	e1a01004 	mov	r1, r4
			                    (((wr2rd_csc_dly & (1<<4))>>4)<<28)|
			                    (((wr2rd_dly & (1<<4))>>4)<<27)|
			                    (((wr2prech_dly & (1<<4))>>4)<<26)|
			                    (((tXP-1))<<20)|
			                    (((tCKE-1))<<16)|
			                    (((sref_exit))<<8)|
 3a4:	e182ae0a 	orr	sl, r2, sl, lsl #28
		//REF_CONFIG

		CKC_CHANGE_ARG(DMC_CH) = (rmw_dly<<28)|(rd2wr_dly<<24)|(wr2wr_csc_dly<<20)|(wr2wr_dly<<16)|(rd2rd_csc_dly<<12)|(rd2rd_dly<<8)|(wr2rd_csc_dly<<4)|wr2rd_dly;
		// DLY_CONFIG_1

		CKC_CHANGE_ARG(DMC_DH) = (((sref_exit & (1<<8))>>8)<<30)|
 3a8:	e588a014 	str	sl, [r8, #20]
			                    (((tCKESR-1)) <<0);
		// DLY_CONFIG_2

		{
			unsigned rd_burst_end_dly = RL+3+(NATIVE_BURST8 ? 2:0);
			unsigned prech2ras_dly    = round_up(DDR3_tRP_ps, 2*tck)-1;
 3ac:	ebfffffe 	bl	0 <__aeabi_uidiv>
			3ac: R_ARM_CALL	__aeabi_uidiv
			unsigned ras2cas_dly      = tRCD;
			unsigned ras2ras_dly      = max(round_up(DDR3_tRRD_ps, 2*tck), round_up(DDR3_tRRD_ck, 2)) - 1;
			//unsigned wr2prech_dly     = ret4(wr2prech_dly);
			unsigned rd2prech_dly     = (HALF_RATE_MODE ? (max(round_up(DDR3_tRTP_ps, 2*tck), round_up(DDR3_tRTP_ck, 2)) - 1) :
 3b0:	e59d201c 	ldr	r2, [sp, #28]
			unsigned zqc_dly = (HALF_RATE_MODE ? (ZQC_SHORT ? round_up(DDR3_tZQCS_ck, 2)-1 : round_up(DDR3_tZQOPER_ck, 2)-1) :
			                        (ZQC_SHORT ? DDR3_tZQCS_ck-1 : DDR3_tZQOPER_ck-1));
			unsigned tfaw_dly = round_up(DDR3_tFAW_ps, 2*tck)-1;
			unsigned ras2ras_same_bank_dly = round_up(DDR3_tRC_ps, 2*tck)-1;
			unsigned swap_phase = SWAP_PHASE;
			unsigned ras2prech_dly = round_up(DDR3_tRAS_ps, 2*tck)-1;
 3b4:	e1a01004 	mov	r1, r4
			                    (((tCKESR-1)) <<0);
		// DLY_CONFIG_2

		{
			unsigned rd_burst_end_dly = RL+3+(NATIVE_BURST8 ? 2:0);
			unsigned prech2ras_dly    = round_up(DDR3_tRP_ps, 2*tck)-1;
 3b8:	e2403001 	sub	r3, r0, #1
			//unsigned wr2prech_dly     = ret4(wr2prech_dly);
			unsigned rd2prech_dly     = (HALF_RATE_MODE ? (max(round_up(DDR3_tRTP_ps, 2*tck), round_up(DDR3_tRTP_ck, 2)) - 1) :
			                                 (max(round_up(DDR3_tRTP_ps, 2*tck), DDR3_tRTP_ck) - 1));
			unsigned prech_all_dly    = round_up(DDR3_tRP_ps, 2*tck);

			CKC_CHANGE_ARG(DMC_EH)= (rd_burst_end_dly<<28)|(prech2ras_dly<<24)|(ras2cas_dly<<20)|(ras2ras_dly<<16)|(wr2prech_dly<<12)|(rd2prech_dly<<8)|(prech_all_dly<<0);
 3bc:	e1800c03 	orr	r0, r0, r3, lsl #24

		{
			unsigned rd_burst_end_dly = RL+3+(NATIVE_BURST8 ? 2:0);
			unsigned prech2ras_dly    = round_up(DDR3_tRP_ps, 2*tck)-1;
			unsigned ras2cas_dly      = tRCD;
			unsigned ras2ras_dly      = max(round_up(DDR3_tRRD_ps, 2*tck), round_up(DDR3_tRRD_ck, 2)) - 1;
 3c0:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 3c4:	e3530002 	cmp	r3, #2
 3c8:	33a03002 	movcc	r3, #2
 3cc:	e2433001 	sub	r3, r3, #1
			//unsigned wr2prech_dly     = ret4(wr2prech_dly);
			unsigned rd2prech_dly     = (HALF_RATE_MODE ? (max(round_up(DDR3_tRTP_ps, 2*tck), round_up(DDR3_tRTP_ck, 2)) - 1) :
			                                 (max(round_up(DDR3_tRTP_ps, 2*tck), DDR3_tRTP_ck) - 1));
			unsigned prech_all_dly    = round_up(DDR3_tRP_ps, 2*tck);

			CKC_CHANGE_ARG(DMC_EH)= (rd_burst_end_dly<<28)|(prech2ras_dly<<24)|(ras2cas_dly<<20)|(ras2ras_dly<<16)|(wr2prech_dly<<12)|(rd2prech_dly<<8)|(prech_all_dly<<0);
 3d0:	e1800803 	orr	r0, r0, r3, lsl #16
			unsigned rd_burst_end_dly = RL+3+(NATIVE_BURST8 ? 2:0);
			unsigned prech2ras_dly    = round_up(DDR3_tRP_ps, 2*tck)-1;
			unsigned ras2cas_dly      = tRCD;
			unsigned ras2ras_dly      = max(round_up(DDR3_tRRD_ps, 2*tck), round_up(DDR3_tRRD_ck, 2)) - 1;
			//unsigned wr2prech_dly     = ret4(wr2prech_dly);
			unsigned rd2prech_dly     = (HALF_RATE_MODE ? (max(round_up(DDR3_tRTP_ps, 2*tck), round_up(DDR3_tRTP_ck, 2)) - 1) :
 3d4:	e2423001 	sub	r3, r2, #1
			                                 (max(round_up(DDR3_tRTP_ps, 2*tck), DDR3_tRTP_ck) - 1));
			unsigned prech_all_dly    = round_up(DDR3_tRP_ps, 2*tck);

			CKC_CHANGE_ARG(DMC_EH)= (rd_burst_end_dly<<28)|(prech2ras_dly<<24)|(ras2cas_dly<<20)|(ras2ras_dly<<16)|(wr2prech_dly<<12)|(rd2prech_dly<<8)|(prech_all_dly<<0);
 3d8:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
 3dc:	e1803403 	orr	r3, r0, r3, lsl #8
			                    (((sref_exit))<<8)|
			                    (((tCKESR-1)) <<0);
		// DLY_CONFIG_2

		{
			unsigned rd_burst_end_dly = RL+3+(NATIVE_BURST8 ? 2:0);
 3e0:	e59d0008 	ldr	r0, [sp, #8]
			//unsigned wr2prech_dly     = ret4(wr2prech_dly);
			unsigned rd2prech_dly     = (HALF_RATE_MODE ? (max(round_up(DDR3_tRTP_ps, 2*tck), round_up(DDR3_tRTP_ck, 2)) - 1) :
			                                 (max(round_up(DDR3_tRTP_ps, 2*tck), DDR3_tRTP_ck) - 1));
			unsigned prech_all_dly    = round_up(DDR3_tRP_ps, 2*tck);

			CKC_CHANGE_ARG(DMC_EH)= (rd_burst_end_dly<<28)|(prech2ras_dly<<24)|(ras2cas_dly<<20)|(ras2ras_dly<<16)|(wr2prech_dly<<12)|(rd2prech_dly<<8)|(prech_all_dly<<0);
 3e4:	e1833602 	orr	r3, r3, r2, lsl #12
			                    (((sref_exit))<<8)|
			                    (((tCKESR-1)) <<0);
		// DLY_CONFIG_2

		{
			unsigned rd_burst_end_dly = RL+3+(NATIVE_BURST8 ? 2:0);
 3e8:	e2802003 	add	r2, r0, #3
			unsigned zqc_dly = (HALF_RATE_MODE ? (ZQC_SHORT ? round_up(DDR3_tZQCS_ck, 2)-1 : round_up(DDR3_tZQOPER_ck, 2)-1) :
			                        (ZQC_SHORT ? DDR3_tZQCS_ck-1 : DDR3_tZQOPER_ck-1));
			unsigned tfaw_dly = round_up(DDR3_tFAW_ps, 2*tck)-1;
			unsigned ras2ras_same_bank_dly = round_up(DDR3_tRC_ps, 2*tck)-1;
			unsigned swap_phase = SWAP_PHASE;
			unsigned ras2prech_dly = round_up(DDR3_tRAS_ps, 2*tck)-1;
 3ec:	e2840b21 	add	r0, r4, #33792	; 0x8400
			//unsigned wr2prech_dly     = ret4(wr2prech_dly);
			unsigned rd2prech_dly     = (HALF_RATE_MODE ? (max(round_up(DDR3_tRTP_ps, 2*tck), round_up(DDR3_tRTP_ck, 2)) - 1) :
			                                 (max(round_up(DDR3_tRTP_ps, 2*tck), DDR3_tRTP_ck) - 1));
			unsigned prech_all_dly    = round_up(DDR3_tRP_ps, 2*tck);

			CKC_CHANGE_ARG(DMC_EH)= (rd_burst_end_dly<<28)|(prech2ras_dly<<24)|(ras2cas_dly<<20)|(ras2ras_dly<<16)|(wr2prech_dly<<12)|(rd2prech_dly<<8)|(prech_all_dly<<0);
 3f0:	e1833e02 	orr	r3, r3, r2, lsl #28
 3f4:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
			unsigned zqc_dly = (HALF_RATE_MODE ? (ZQC_SHORT ? round_up(DDR3_tZQCS_ck, 2)-1 : round_up(DDR3_tZQOPER_ck, 2)-1) :
			                        (ZQC_SHORT ? DDR3_tZQCS_ck-1 : DDR3_tZQOPER_ck-1));
			unsigned tfaw_dly = round_up(DDR3_tFAW_ps, 2*tck)-1;
			unsigned ras2ras_same_bank_dly = round_up(DDR3_tRC_ps, 2*tck)-1;
			unsigned swap_phase = SWAP_PHASE;
			unsigned ras2prech_dly = round_up(DDR3_tRAS_ps, 2*tck)-1;
 3f8:	e28000cf 	add	r0, r0, #207	; 0xcf
			//unsigned wr2prech_dly     = ret4(wr2prech_dly);
			unsigned rd2prech_dly     = (HALF_RATE_MODE ? (max(round_up(DDR3_tRTP_ps, 2*tck), round_up(DDR3_tRTP_ck, 2)) - 1) :
			                                 (max(round_up(DDR3_tRTP_ps, 2*tck), DDR3_tRTP_ck) - 1));
			unsigned prech_all_dly    = round_up(DDR3_tRP_ps, 2*tck);

			CKC_CHANGE_ARG(DMC_EH)= (rd_burst_end_dly<<28)|(prech2ras_dly<<24)|(ras2cas_dly<<20)|(ras2ras_dly<<16)|(wr2prech_dly<<12)|(rd2prech_dly<<8)|(prech_all_dly<<0);
 3fc:	e1833a02 	orr	r3, r3, r2, lsl #20
 400:	e5883018 	str	r3, [r8, #24]
			unsigned zqc_dly = (HALF_RATE_MODE ? (ZQC_SHORT ? round_up(DDR3_tZQCS_ck, 2)-1 : round_up(DDR3_tZQOPER_ck, 2)-1) :
			                        (ZQC_SHORT ? DDR3_tZQCS_ck-1 : DDR3_tZQOPER_ck-1));
			unsigned tfaw_dly = round_up(DDR3_tFAW_ps, 2*tck)-1;
			unsigned ras2ras_same_bank_dly = round_up(DDR3_tRC_ps, 2*tck)-1;
			unsigned swap_phase = SWAP_PHASE;
			unsigned ras2prech_dly = round_up(DDR3_tRAS_ps, 2*tck)-1;
 404:	ebfffffe 	bl	0 <__aeabi_uidiv>
			404: R_ARM_CALL	__aeabi_uidiv
	}	

		{
			unsigned zqc_dly = (HALF_RATE_MODE ? (ZQC_SHORT ? round_up(DDR3_tZQCS_ck, 2)-1 : round_up(DDR3_tZQOPER_ck, 2)-1) :
			                        (ZQC_SHORT ? DDR3_tZQCS_ck-1 : DDR3_tZQOPER_ck-1));
			unsigned tfaw_dly = round_up(DDR3_tFAW_ps, 2*tck)-1;
 408:	e1a01004 	mov	r1, r4
			unsigned ras2ras_same_bank_dly = round_up(DDR3_tRC_ps, 2*tck)-1;
			unsigned swap_phase = SWAP_PHASE;
			unsigned ras2prech_dly = round_up(DDR3_tRAS_ps, 2*tck)-1;
 40c:	e2400001 	sub	r0, r0, #1

			CKC_CHANGE_ARG(DMC_FH) = ((zqc_dly<<24)|(tfaw_dly<<16)|(ras2ras_same_bank_dly<<8)|(swap_phase<<5)|(ras2prech_dly<<0));
 410:	e380a47f 	orr	sl, r0, #2130706432	; 0x7f000000
	}	

		{
			unsigned zqc_dly = (HALF_RATE_MODE ? (ZQC_SHORT ? round_up(DDR3_tZQCS_ck, 2)-1 : round_up(DDR3_tZQOPER_ck, 2)-1) :
			                        (ZQC_SHORT ? DDR3_tZQCS_ck-1 : DDR3_tZQOPER_ck-1));
			unsigned tfaw_dly = round_up(DDR3_tFAW_ps, 2*tck)-1;
 414:	e2840b22 	add	r0, r4, #34816	; 0x8800
 418:	e28000b7 	add	r0, r0, #183	; 0xb7
 41c:	ebfffffe 	bl	0 <__aeabi_uidiv>
			41c: R_ARM_CALL	__aeabi_uidiv
			unsigned ras2ras_same_bank_dly = round_up(DDR3_tRC_ps, 2*tck)-1;
 420:	e1a01004 	mov	r1, r4
	}	

		{
			unsigned zqc_dly = (HALF_RATE_MODE ? (ZQC_SHORT ? round_up(DDR3_tZQCS_ck, 2)-1 : round_up(DDR3_tZQOPER_ck, 2)-1) :
			                        (ZQC_SHORT ? DDR3_tZQCS_ck-1 : DDR3_tZQOPER_ck-1));
			unsigned tfaw_dly = round_up(DDR3_tFAW_ps, 2*tck)-1;
 424:	e2400001 	sub	r0, r0, #1
			unsigned ras2ras_same_bank_dly = round_up(DDR3_tRC_ps, 2*tck)-1;
			unsigned swap_phase = SWAP_PHASE;
			unsigned ras2prech_dly = round_up(DDR3_tRAS_ps, 2*tck)-1;

			CKC_CHANGE_ARG(DMC_FH) = ((zqc_dly<<24)|(tfaw_dly<<16)|(ras2ras_same_bank_dly<<8)|(swap_phase<<5)|(ras2prech_dly<<0));
 428:	e18aa800 	orr	sl, sl, r0, lsl #16

		{
			unsigned zqc_dly = (HALF_RATE_MODE ? (ZQC_SHORT ? round_up(DDR3_tZQCS_ck, 2)-1 : round_up(DDR3_tZQOPER_ck, 2)-1) :
			                        (ZQC_SHORT ? DDR3_tZQCS_ck-1 : DDR3_tZQOPER_ck-1));
			unsigned tfaw_dly = round_up(DDR3_tFAW_ps, 2*tck)-1;
			unsigned ras2ras_same_bank_dly = round_up(DDR3_tRC_ps, 2*tck)-1;
 42c:	e2840cbb 	add	r0, r4, #47872	; 0xbb00
 430:	e2800025 	add	r0, r0, #37	; 0x25
 434:	ebfffffe 	bl	0 <__aeabi_uidiv>
			434: R_ARM_CALL	__aeabi_uidiv

			CKC_CHANGE_ARG(DMC_FH) = ((zqc_dly<<24)|(tfaw_dly<<16)|(ras2ras_same_bank_dly<<8)|(swap_phase<<5)|(ras2prech_dly<<0));
			// DLY_CONFIG_4
	}

		CKC_CHANGE_ARG(DMC_15H) = ((tXS-1)<<24)|(ZQC_SHORT<<23)|(AUTO_ZQC_ENABLE<<22)|ZQC_INTERVAL;
 438:	e59f32ac 	ldr	r3, [pc, #684]	; 6ec <change_mem_clock+0x6ec>
		// ZQC_CONFIG


		{
			unsigned odt_len_wr = (HALF_RATE_MODE) ? (3-nCWL%2) : 5;
 43c:	e59d2010 	ldr	r2, [sp, #16]

		{
			unsigned zqc_dly = (HALF_RATE_MODE ? (ZQC_SHORT ? round_up(DDR3_tZQCS_ck, 2)-1 : round_up(DDR3_tZQOPER_ck, 2)-1) :
			                        (ZQC_SHORT ? DDR3_tZQCS_ck-1 : DDR3_tZQOPER_ck-1));
			unsigned tfaw_dly = round_up(DDR3_tFAW_ps, 2*tck)-1;
			unsigned ras2ras_same_bank_dly = round_up(DDR3_tRC_ps, 2*tck)-1;
 440:	e2400001 	sub	r0, r0, #1
			unsigned swap_phase = SWAP_PHASE;
			unsigned ras2prech_dly = round_up(DDR3_tRAS_ps, 2*tck)-1;

			CKC_CHANGE_ARG(DMC_FH) = ((zqc_dly<<24)|(tfaw_dly<<16)|(ras2ras_same_bank_dly<<8)|(swap_phase<<5)|(ras2prech_dly<<0));
 444:	e18aa400 	orr	sl, sl, r0, lsl #8
 448:	e588a01c 	str	sl, [r8, #28]
			// DLY_CONFIG_4
	}

		CKC_CHANGE_ARG(DMC_15H) = ((tXS-1)<<24)|(ZQC_SHORT<<23)|(AUTO_ZQC_ENABLE<<22)|ZQC_INTERVAL;
 44c:	e5883028 	str	r3, [r8, #40]	; 0x28
		// ZQC_CONFIG


		{
			unsigned odt_len_wr = (HALF_RATE_MODE) ? (3-nCWL%2) : 5;
 450:	e2623003 	rsb	r3, r2, #3
			unsigned odt_len_rd = (HALF_RATE_MODE) ? (2 + (((nCL-nCWL) % 2 == 0) && (nCL-nCWL > 0)) ? 1 : 0) : 5;
			unsigned odt_wr_set_dly = 1;
			unsigned odt_rd_set_dly = (HALF_RATE_MODE) ? ( (nCL - nCWL - (nCL - nCWL > 0 ? 1 : 0))/2 ) : (RL-WL);
 454:	e59d2018 	ldr	r2, [sp, #24]
	//MR1
//	HOST_CMD_LOAD1(3, 0x100|((ret_mr1(0, RTT_NOM, DIC)&0xFF00)>>8), ((ret_mr1(0, RTT_NOM, DIC)&0x00FF)<<24)|CMD_MRS, round_up(max(DDR3_tMOD_ps, DDR3_tMOD_ck*tck), wait_cycle));


	CKC_CHANGE_ARG(DMC_20H) = IDLE_NOP;
	CKC_CHANGE_ARG(DMC_30H) = (max(round_up(max(DDR3_tXS_ps, DDR3_tXS_ck*tck), wait_cycle), 1) -1)<<12 | 0;
 458:	e1a0a106 	lsl	sl, r6, #2
			unsigned odt_len_rd = (HALF_RATE_MODE) ? (2 + (((nCL-nCWL) % 2 == 0) && (nCL-nCWL > 0)) ? 1 : 0) : 5;
			unsigned odt_wr_set_dly = 1;
			unsigned odt_rd_set_dly = (HALF_RATE_MODE) ? ( (nCL - nCWL - (nCL - nCWL > 0 ? 1 : 0))/2 ) : (RL-WL);
			unsigned odt_en_sel =  0;			

			CKC_CHANGE_ARG(DMC_10H) = (odt_len_wr<<20)|(odt_len_rd<<16)|(odt_wr_set_dly<<12)|(odt_rd_set_dly<<8)|odt_en_sel;
 45c:	e1a03a03 	lsl	r3, r3, #20
 460:	e59d0010 	ldr	r0, [sp, #16]

		{
			unsigned odt_len_wr = (HALF_RATE_MODE) ? (3-nCWL%2) : 5;
			unsigned odt_len_rd = (HALF_RATE_MODE) ? (2 + (((nCL-nCWL) % 2 == 0) && (nCL-nCWL > 0)) ? 1 : 0) : 5;
			unsigned odt_wr_set_dly = 1;
			unsigned odt_rd_set_dly = (HALF_RATE_MODE) ? ( (nCL - nCWL - (nCL - nCWL > 0 ? 1 : 0))/2 ) : (RL-WL);
 464:	e1550007 	cmp	r5, r7
 468:	12422001 	subne	r2, r2, #1
			unsigned odt_en_sel =  0;			

			CKC_CHANGE_ARG(DMC_10H) = (odt_len_wr<<20)|(odt_len_rd<<16)|(odt_wr_set_dly<<12)|(odt_rd_set_dly<<8)|odt_en_sel;
 46c:	e3833a11 	orr	r3, r3, #69632	; 0x11000

		{
			unsigned odt_len_wr = (HALF_RATE_MODE) ? (3-nCWL%2) : 5;
			unsigned odt_len_rd = (HALF_RATE_MODE) ? (2 + (((nCL-nCWL) % 2 == 0) && (nCL-nCWL > 0)) ? 1 : 0) : 5;
			unsigned odt_wr_set_dly = 1;
			unsigned odt_rd_set_dly = (HALF_RATE_MODE) ? ( (nCL - nCWL - (nCL - nCWL > 0 ? 1 : 0))/2 ) : (RL-WL);
 470:	e1a070a2 	lsr	r7, r2, #1
			unsigned odt_en_sel =  0;			

			CKC_CHANGE_ARG(DMC_10H) = (odt_len_wr<<20)|(odt_len_rd<<16)|(odt_wr_set_dly<<12)|(odt_rd_set_dly<<8)|odt_en_sel;
 474:	e1837407 	orr	r7, r3, r7, lsl #8
			// ODT_CONFIG
		}

		CKC_CHANGE_ARG(DMC_11H) = (BIG_ENDIAN<<31)|(7<<28)|(3<<24)|((RL-3-C2D)<<16)|(0<<12)|(0<<8)|(0<<4)|(WL-C2D-1-(nCWL%2 == 0 && !SWAP_PHASE && HALF_RATE_MODE));
 478:	e59d3008 	ldr	r3, [sp, #8]
			unsigned odt_len_rd = (HALF_RATE_MODE) ? (2 + (((nCL-nCWL) % 2 == 0) && (nCL-nCWL > 0)) ? 1 : 0) : 5;
			unsigned odt_wr_set_dly = 1;
			unsigned odt_rd_set_dly = (HALF_RATE_MODE) ? ( (nCL - nCWL - (nCL - nCWL > 0 ? 1 : 0))/2 ) : (RL-WL);
			unsigned odt_en_sel =  0;			

			CKC_CHANGE_ARG(DMC_10H) = (odt_len_wr<<20)|(odt_len_rd<<16)|(odt_wr_set_dly<<12)|(odt_rd_set_dly<<8)|odt_en_sel;
 47c:	e5887020 	str	r7, [r8, #32]
			// ODT_CONFIG
		}

		CKC_CHANGE_ARG(DMC_11H) = (BIG_ENDIAN<<31)|(7<<28)|(3<<24)|((RL-3-C2D)<<16)|(0<<12)|(0<<8)|(0<<4)|(WL-C2D-1-(nCWL%2 == 0 && !SWAP_PHASE && HALF_RATE_MODE));
 480:	e2432005 	sub	r2, r3, #5
 484:	e59d300c 	ldr	r3, [sp, #12]
 488:	e2431003 	sub	r1, r3, #3
 48c:	e2203001 	eor	r3, r0, #1
 490:	e0633001 	rsb	r3, r3, r1
	//MR1
//	HOST_CMD_LOAD1(3, 0x100|((ret_mr1(0, RTT_NOM, DIC)&0xFF00)>>8), ((ret_mr1(0, RTT_NOM, DIC)&0x00FF)<<24)|CMD_MRS, round_up(max(DDR3_tMOD_ps, DDR3_tMOD_ck*tck), wait_cycle));


	CKC_CHANGE_ARG(DMC_20H) = IDLE_NOP;
	CKC_CHANGE_ARG(DMC_30H) = (max(round_up(max(DDR3_tXS_ps, DDR3_tXS_ck*tck), wait_cycle), 1) -1)<<12 | 0;
 494:	e08a0006 	add	r0, sl, r6

			CKC_CHANGE_ARG(DMC_10H) = (odt_len_wr<<20)|(odt_len_rd<<16)|(odt_wr_set_dly<<12)|(odt_rd_set_dly<<8)|odt_en_sel;
			// ODT_CONFIG
		}

		CKC_CHANGE_ARG(DMC_11H) = (BIG_ENDIAN<<31)|(7<<28)|(3<<24)|((RL-3-C2D)<<16)|(0<<12)|(0<<8)|(0<<4)|(WL-C2D-1-(nCWL%2 == 0 && !SWAP_PHASE && HALF_RATE_MODE));
 498:	e1833802 	orr	r3, r3, r2, lsl #16
	//MR1
//	HOST_CMD_LOAD1(3, 0x100|((ret_mr1(0, RTT_NOM, DIC)&0xFF00)>>8), ((ret_mr1(0, RTT_NOM, DIC)&0x00FF)<<24)|CMD_MRS, round_up(max(DDR3_tMOD_ps, DDR3_tMOD_ck*tck), wait_cycle));


	CKC_CHANGE_ARG(DMC_20H) = IDLE_NOP;
	CKC_CHANGE_ARG(DMC_30H) = (max(round_up(max(DDR3_tXS_ps, DDR3_tXS_ck*tck), wait_cycle), 1) -1)<<12 | 0;
 49c:	e59f224c 	ldr	r2, [pc, #588]	; 6f0 <change_mem_clock+0x6f0>

			CKC_CHANGE_ARG(DMC_10H) = (odt_len_wr<<20)|(odt_len_rd<<16)|(odt_wr_set_dly<<12)|(odt_rd_set_dly<<8)|odt_en_sel;
			// ODT_CONFIG
		}

		CKC_CHANGE_ARG(DMC_11H) = (BIG_ENDIAN<<31)|(7<<28)|(3<<24)|((RL-3-C2D)<<16)|(0<<12)|(0<<8)|(0<<4)|(WL-C2D-1-(nCWL%2 == 0 && !SWAP_PHASE && HALF_RATE_MODE));
 4a0:	e3833473 	orr	r3, r3, #1929379840	; 0x73000000
 4a4:	e5883024 	str	r3, [r8, #36]	; 0x24

	//MR1
//	HOST_CMD_LOAD1(3, 0x100|((ret_mr1(0, RTT_NOM, DIC)&0xFF00)>>8), ((ret_mr1(0, RTT_NOM, DIC)&0x00FF)<<24)|CMD_MRS, round_up(max(DDR3_tMOD_ps, DDR3_tMOD_ck*tck), wait_cycle));


	CKC_CHANGE_ARG(DMC_20H) = IDLE_NOP;
 4a8:	e3e034ff 	mvn	r3, #-16777216	; 0xff000000
 4ac:	e588302c 	str	r3, [r8, #44]	; 0x2c
	CKC_CHANGE_ARG(DMC_30H) = (max(round_up(max(DDR3_tXS_ps, DDR3_tXS_ck*tck), wait_cycle), 1) -1)<<12 | 0;
 4b0:	e2443001 	sub	r3, r4, #1
 4b4:	e1a01004 	mov	r1, r4
 4b8:	e1500002 	cmp	r0, r2
 4bc:	20830000 	addcs	r0, r3, r0
 4c0:	30830002 	addcc	r0, r3, r2
 4c4:	ebfffffe 	bl	0 <__aeabi_uidiv>
			4c4: R_ARM_CALL	__aeabi_uidiv

	CKC_CHANGE_ARG(DMC_21H) = ((ret_mr0(round_up(DDR3_tWR_ps, tck),1,nCL)&0x00FF)<<24)|CMD_MRS;
 4c8:	e1a01006 	mov	r1, r6
	//MR1
//	HOST_CMD_LOAD1(3, 0x100|((ret_mr1(0, RTT_NOM, DIC)&0xFF00)>>8), ((ret_mr1(0, RTT_NOM, DIC)&0x00FF)<<24)|CMD_MRS, round_up(max(DDR3_tMOD_ps, DDR3_tMOD_ck*tck), wait_cycle));


	CKC_CHANGE_ARG(DMC_20H) = IDLE_NOP;
	CKC_CHANGE_ARG(DMC_30H) = (max(round_up(max(DDR3_tXS_ps, DDR3_tXS_ck*tck), wait_cycle), 1) -1)<<12 | 0;
 4cc:	e3500001 	cmp	r0, #1
 4d0:	33a00001 	movcc	r0, #1
 4d4:	e2403001 	sub	r3, r0, #1

	CKC_CHANGE_ARG(DMC_21H) = ((ret_mr0(round_up(DDR3_tWR_ps, tck),1,nCL)&0x00FF)<<24)|CMD_MRS;
 4d8:	e2860dea 	add	r0, r6, #14976	; 0x3a80
 4dc:	e2800017 	add	r0, r0, #23
	//MR1
//	HOST_CMD_LOAD1(3, 0x100|((ret_mr1(0, RTT_NOM, DIC)&0xFF00)>>8), ((ret_mr1(0, RTT_NOM, DIC)&0x00FF)<<24)|CMD_MRS, round_up(max(DDR3_tMOD_ps, DDR3_tMOD_ck*tck), wait_cycle));


	CKC_CHANGE_ARG(DMC_20H) = IDLE_NOP;
	CKC_CHANGE_ARG(DMC_30H) = (max(round_up(max(DDR3_tXS_ps, DDR3_tXS_ck*tck), wait_cycle), 1) -1)<<12 | 0;
 4e0:	e1a03603 	lsl	r3, r3, #12
 4e4:	e5883040 	str	r3, [r8, #64]	; 0x40

	CKC_CHANGE_ARG(DMC_21H) = ((ret_mr0(round_up(DDR3_tWR_ps, tck),1,nCL)&0x00FF)<<24)|CMD_MRS;
 4e8:	ebfffffe 	bl	0 <__aeabi_uidiv>
			4e8: R_ARM_CALL	__aeabi_uidiv

inline static unsigned
wr2mr (unsigned n)
{
  unsigned wr_val = 0;
  switch (n)
 4ec:	e2407005 	sub	r7, r0, #5


	CKC_CHANGE_ARG(DMC_20H) = IDLE_NOP;
	CKC_CHANGE_ARG(DMC_30H) = (max(round_up(max(DDR3_tXS_ps, DDR3_tXS_ck*tck), wait_cycle), 1) -1)<<12 | 0;

	CKC_CHANGE_ARG(DMC_21H) = ((ret_mr0(round_up(DDR3_tWR_ps, tck),1,nCL)&0x00FF)<<24)|CMD_MRS;
 4f0:	e1a08000 	mov	r8, r0

inline static unsigned
wr2mr (unsigned n)
{
  unsigned wr_val = 0;
  switch (n)
 4f4:	e357000b 	cmp	r7, #11
 4f8:	979ff107 	ldrls	pc, [pc, r7, lsl #2]
 4fc:	ea000011 	b	548 <change_mem_clock+0x548>
 500:	00000538 	.word	0x00000538
			500: R_ARM_ABS32	.text.change_mem_clock
 504:	00000538 	.word	0x00000538
			504: R_ARM_ABS32	.text.change_mem_clock
 508:	00000538 	.word	0x00000538
			508: R_ARM_ABS32	.text.change_mem_clock
 50c:	00000538 	.word	0x00000538
			50c: R_ARM_ABS32	.text.change_mem_clock
 510:	00000530 	.word	0x00000530
			510: R_ARM_ABS32	.text.change_mem_clock
 514:	00000530 	.word	0x00000530
			514: R_ARM_ABS32	.text.change_mem_clock
 518:	00000550 	.word	0x00000550
			518: R_ARM_ABS32	.text.change_mem_clock
 51c:	00000550 	.word	0x00000550
			51c: R_ARM_ABS32	.text.change_mem_clock
 520:	00000540 	.word	0x00000540
			520: R_ARM_ABS32	.text.change_mem_clock
 524:	00000540 	.word	0x00000540
			524: R_ARM_ABS32	.text.change_mem_clock
 528:	00000548 	.word	0x00000548
			528: R_ARM_ABS32	.text.change_mem_clock
 52c:	00000548 	.word	0x00000548
			52c: R_ARM_ABS32	.text.change_mem_clock
    case 8:
      wr_val = n - 4;
      break;
    case 9:
    case 10:
      wr_val = 5;
 530:	e3a03005 	mov	r3, #5
 534:	ea000006 	b	554 <change_mem_clock+0x554>
    {
    case 5:
    case 6:
    case 7:
    case 8:
      wr_val = n - 4;
 538:	e2403004 	sub	r3, r0, #4
 53c:	ea000004 	b	554 <change_mem_clock+0x554>
    case 12:
      wr_val = 6;
      break;
    case 13:
    case 14:
      wr_val = 7;
 540:	e3a03007 	mov	r3, #7
 544:	ea000002 	b	554 <change_mem_clock+0x554>
    case 15:
    case 16:
      wr_val = 0;
      break;
    default:
      wr_val = 0;
 548:	e3a03000 	mov	r3, #0
 54c:	ea000000 	b	554 <change_mem_clock+0x554>
    case 10:
      wr_val = 5;
      break;
    case 11:
    case 12:
      wr_val = 6;
 550:	e3a03006 	mov	r3, #6
inline static unsigned
cl2mr (unsigned n)
{
  unsigned cl;

  if (n > 11) cl = (((n - 12) << 2) | 1);
 554:	e355000b 	cmp	r5, #11


	CKC_CHANGE_ARG(DMC_20H) = IDLE_NOP;
	CKC_CHANGE_ARG(DMC_30H) = (max(round_up(max(DDR3_tXS_ps, DDR3_tXS_ck*tck), wait_cycle), 1) -1)<<12 | 0;

	CKC_CHANGE_ARG(DMC_21H) = ((ret_mr0(round_up(DDR3_tWR_ps, tck),1,nCL)&0x00FF)<<24)|CMD_MRS;
 558:	e1a03483 	lsl	r3, r3, #9
inline static unsigned
cl2mr (unsigned n)
{
  unsigned cl;

  if (n > 11) cl = (((n - 12) << 2) | 1);
 55c:	8245200c 	subhi	r2, r5, #12
  else        cl = (((n -   4) << 2) | 0);
 560:	92452004 	subls	r2, r5, #4

	CKC_CHANGE_ARG(DMC_20H) = IDLE_NOP;
	CKC_CHANGE_ARG(DMC_30H) = (max(round_up(max(DDR3_tXS_ps, DDR3_tXS_ck*tck), wait_cycle), 1) -1)<<12 | 0;

	CKC_CHANGE_ARG(DMC_21H) = ((ret_mr0(round_up(DDR3_tWR_ps, tck),1,nCL)&0x00FF)<<24)|CMD_MRS;
	CKC_CHANGE_ARG(DMC_31H) = ((max(round_up(DDR3_tMRD_ck*tck, wait_cycle),1)-1)<<12)|(0x000|((ret_mr0(round_up(DDR3_tWR_ps, tck),1,nCL)&0xFF00)>>8));
 564:	e084a00a 	add	sl, r4, sl
 568:	e1a01004 	mov	r1, r4
inline static unsigned
cl2mr (unsigned n)
{
  unsigned cl;

  if (n > 11) cl = (((n - 12) << 2) | 1);
 56c:	81a02102 	lslhi	r2, r2, #2
  else        cl = (((n -   4) << 2) | 0);
 570:	91a02102 	lslls	r2, r2, #2
inline static unsigned
cl2mr (unsigned n)
{
  unsigned cl;

  if (n > 11) cl = (((n - 12) << 2) | 1);
 574:	83822001 	orrhi	r2, r2, #1

	CKC_CHANGE_ARG(DMC_20H) = IDLE_NOP;
	CKC_CHANGE_ARG(DMC_30H) = (max(round_up(max(DDR3_tXS_ps, DDR3_tXS_ck*tck), wait_cycle), 1) -1)<<12 | 0;

	CKC_CHANGE_ARG(DMC_21H) = ((ret_mr0(round_up(DDR3_tWR_ps, tck),1,nCL)&0x00FF)<<24)|CMD_MRS;
	CKC_CHANGE_ARG(DMC_31H) = ((max(round_up(DDR3_tMRD_ck*tck, wait_cycle),1)-1)<<12)|(0x000|((ret_mr0(round_up(DDR3_tWR_ps, tck),1,nCL)&0xFF00)>>8));
 578:	e24a0001 	sub	r0, sl, #1


	CKC_CHANGE_ARG(DMC_20H) = IDLE_NOP;
	CKC_CHANGE_ARG(DMC_30H) = (max(round_up(max(DDR3_tXS_ps, DDR3_tXS_ck*tck), wait_cycle), 1) -1)<<12 | 0;

	CKC_CHANGE_ARG(DMC_21H) = ((ret_mr0(round_up(DDR3_tWR_ps, tck),1,nCL)&0x00FF)<<24)|CMD_MRS;
 57c:	e1833102 	orr	r3, r3, r2, lsl #2
 580:	e59f216c 	ldr	r2, [pc, #364]	; 6f4 <change_mem_clock+0x6f4>
 584:	e1a03c03 	lsl	r3, r3, #24
 588:	e1832002 	orr	r2, r3, r2
 58c:	e59f3134 	ldr	r3, [pc, #308]	; 6c8 <change_mem_clock+0x6c8>
 590:	e5832030 	str	r2, [r3, #48]	; 0x30
	CKC_CHANGE_ARG(DMC_31H) = ((max(round_up(DDR3_tMRD_ck*tck, wait_cycle),1)-1)<<12)|(0x000|((ret_mr0(round_up(DDR3_tWR_ps, tck),1,nCL)&0xFF00)>>8));
 594:	ebfffffe 	bl	0 <__aeabi_uidiv>
			594: R_ARM_CALL	__aeabi_uidiv
 598:	e3500001 	cmp	r0, #1
 59c:	33a00001 	movcc	r0, #1
 5a0:	e2402001 	sub	r2, r0, #1
 5a4:	e1a02602 	lsl	r2, r2, #12

inline static unsigned
wr2mr (unsigned n)
{
  unsigned wr_val = 0;
  switch (n)
 5a8:	e357000b 	cmp	r7, #11
 5ac:	979ff107 	ldrls	pc, [pc, r7, lsl #2]
 5b0:	ea000011 	b	5fc <change_mem_clock+0x5fc>
 5b4:	000005ec 	.word	0x000005ec
			5b4: R_ARM_ABS32	.text.change_mem_clock
 5b8:	000005ec 	.word	0x000005ec
			5b8: R_ARM_ABS32	.text.change_mem_clock
 5bc:	000005ec 	.word	0x000005ec
			5bc: R_ARM_ABS32	.text.change_mem_clock
 5c0:	000005ec 	.word	0x000005ec
			5c0: R_ARM_ABS32	.text.change_mem_clock
 5c4:	000005e4 	.word	0x000005e4
			5c4: R_ARM_ABS32	.text.change_mem_clock
 5c8:	000005e4 	.word	0x000005e4
			5c8: R_ARM_ABS32	.text.change_mem_clock
 5cc:	00000604 	.word	0x00000604
			5cc: R_ARM_ABS32	.text.change_mem_clock
 5d0:	00000604 	.word	0x00000604
			5d0: R_ARM_ABS32	.text.change_mem_clock
 5d4:	000005f4 	.word	0x000005f4
			5d4: R_ARM_ABS32	.text.change_mem_clock
 5d8:	000005f4 	.word	0x000005f4
			5d8: R_ARM_ABS32	.text.change_mem_clock
 5dc:	000005fc 	.word	0x000005fc
			5dc: R_ARM_ABS32	.text.change_mem_clock
 5e0:	000005fc 	.word	0x000005fc
			5e0: R_ARM_ABS32	.text.change_mem_clock
    case 8:
      wr_val = n - 4;
      break;
    case 9:
    case 10:
      wr_val = 5;
 5e4:	e3a00005 	mov	r0, #5
 5e8:	ea000006 	b	608 <change_mem_clock+0x608>
    {
    case 5:
    case 6:
    case 7:
    case 8:
      wr_val = n - 4;
 5ec:	e2480004 	sub	r0, r8, #4
 5f0:	ea000004 	b	608 <change_mem_clock+0x608>
    case 12:
      wr_val = 6;
      break;
    case 13:
    case 14:
      wr_val = 7;
 5f4:	e3a00007 	mov	r0, #7
 5f8:	ea000002 	b	608 <change_mem_clock+0x608>
    case 15:
    case 16:
      wr_val = 0;
      break;
    default:
      wr_val = 0;
 5fc:	e3a00000 	mov	r0, #0
 600:	ea000000 	b	608 <change_mem_clock+0x608>
    case 10:
      wr_val = 5;
      break;
    case 11:
    case 12:
      wr_val = 6;
 604:	e3a00006 	mov	r0, #6
inline static unsigned
cl2mr (unsigned n)
{
  unsigned cl;

  if (n > 11) cl = (((n - 12) << 2) | 1);
 608:	e355000b 	cmp	r5, #11

	CKC_CHANGE_ARG(DMC_20H) = IDLE_NOP;
	CKC_CHANGE_ARG(DMC_30H) = (max(round_up(max(DDR3_tXS_ps, DDR3_tXS_ck*tck), wait_cycle), 1) -1)<<12 | 0;

	CKC_CHANGE_ARG(DMC_21H) = ((ret_mr0(round_up(DDR3_tWR_ps, tck),1,nCL)&0x00FF)<<24)|CMD_MRS;
	CKC_CHANGE_ARG(DMC_31H) = ((max(round_up(DDR3_tMRD_ck*tck, wait_cycle),1)-1)<<12)|(0x000|((ret_mr0(round_up(DDR3_tWR_ps, tck),1,nCL)&0xFF00)>>8));
 60c:	e1a03480 	lsl	r3, r0, #9
inline static unsigned
cl2mr (unsigned n)
{
  unsigned cl;

  if (n > 11) cl = (((n - 12) << 2) | 1);
 610:	8245500c 	subhi	r5, r5, #12
  else        cl = (((n -   4) << 2) | 0);
 614:	92455004 	subls	r5, r5, #4

//	CKC_CHANGE_ARG(DMC_22H) = ((ret_mr1(0, RTT_NOM, DIC)&0x00FF)<<24)|CMD_MRS;
//	CKC_CHANGE_ARG(DMC_32H) = ((max(round_up(max(DDR3_tMOD_ps, DDR3_tMOD_ck*tck), wait_cycle),1)-1)<<12)|(0x100|((ret_mr1(0, RTT_NOM, DIC)&0xFF00)>>8));

	CKC_CHANGE_ARG(DMC_22H) = ((ret_mr2(nCWL,RTT_WR)&0x00FF)<<24)|CMD_MRS;
	CKC_CHANGE_ARG(DMC_32H) = ((max(round_up(DDR3_tDLLK_ck*tck, wait_cycle), 1)-1)<<12)|(0x200|((ret_mr2(nCWL, RTT_WR)&0xFF00)>>8));
 618:	e1a01004 	mov	r1, r4
inline static unsigned
cl2mr (unsigned n)
{
  unsigned cl;

  if (n > 11) cl = (((n - 12) << 2) | 1);
 61c:	81a05105 	lslhi	r5, r5, #2
  else        cl = (((n -   4) << 2) | 0);
 620:	91a05105 	lslls	r5, r5, #2
inline static unsigned
cl2mr (unsigned n)
{
  unsigned cl;

  if (n > 11) cl = (((n - 12) << 2) | 1);
 624:	83855001 	orrhi	r5, r5, #1

	CKC_CHANGE_ARG(DMC_20H) = IDLE_NOP;
	CKC_CHANGE_ARG(DMC_30H) = (max(round_up(max(DDR3_tXS_ps, DDR3_tXS_ck*tck), wait_cycle), 1) -1)<<12 | 0;

	CKC_CHANGE_ARG(DMC_21H) = ((ret_mr0(round_up(DDR3_tWR_ps, tck),1,nCL)&0x00FF)<<24)|CMD_MRS;
	CKC_CHANGE_ARG(DMC_31H) = ((max(round_up(DDR3_tMRD_ck*tck, wait_cycle),1)-1)<<12)|(0x000|((ret_mr0(round_up(DDR3_tWR_ps, tck),1,nCL)&0xFF00)>>8));
 628:	e1833105 	orr	r3, r3, r5, lsl #2
 62c:	e59f5094 	ldr	r5, [pc, #148]	; 6c8 <change_mem_clock+0x6c8>
 630:	e2033cee 	and	r3, r3, #60928	; 0xee00
 634:	e3833c11 	orr	r3, r3, #4352	; 0x1100
 638:	e1823423 	orr	r3, r2, r3, lsr #8
 63c:	e5853044 	str	r3, [r5, #68]	; 0x44

//	CKC_CHANGE_ARG(DMC_22H) = ((ret_mr1(0, RTT_NOM, DIC)&0x00FF)<<24)|CMD_MRS;
//	CKC_CHANGE_ARG(DMC_32H) = ((max(round_up(max(DDR3_tMOD_ps, DDR3_tMOD_ck*tck), wait_cycle),1)-1)<<12)|(0x100|((ret_mr1(0, RTT_NOM, DIC)&0xFF00)>>8));

	CKC_CHANGE_ARG(DMC_22H) = ((ret_mr2(nCWL,RTT_WR)&0x00FF)<<24)|CMD_MRS;
 640:	e59d3014 	ldr	r3, [sp, #20]
 644:	e2032007 	and	r2, r3, #7
 648:	e59f30a4 	ldr	r3, [pc, #164]	; 6f4 <change_mem_clock+0x6f4>
 64c:	e1a02d82 	lsl	r2, r2, #27
 650:	e1823003 	orr	r3, r2, r3
 654:	e5853034 	str	r3, [r5, #52]	; 0x34
	CKC_CHANGE_ARG(DMC_32H) = ((max(round_up(DDR3_tDLLK_ck*tck, wait_cycle), 1)-1)<<12)|(0x200|((ret_mr2(nCWL, RTT_WR)&0xFF00)>>8));
 658:	e3a03f7f 	mov	r3, #508	; 0x1fc
 65c:	e020a693 	mla	r0, r3, r6, sl
 660:	e2400001 	sub	r0, r0, #1
 664:	ebfffffe 	bl	0 <__aeabi_uidiv>
			664: R_ARM_CALL	__aeabi_uidiv
 668:	e3500001 	cmp	r0, #1
 66c:	33a00001 	movcc	r0, #1
 670:	e2403001 	sub	r3, r0, #1
 674:	e1a03603 	lsl	r3, r3, #12
 678:	e3833c02 	orr	r3, r3, #512	; 0x200
 67c:	e3833002 	orr	r3, r3, #2
 680:	e5853048 	str	r3, [r5, #72]	; 0x48

	mem_freq = get_membus_ckc(freq);
	printf("MEM FREQ: %dMHz\n", mem_freq);
	get_ddr_param(mem_freq);

	__asm__ __volatile__( \
 684:	e10f4000 	mrs	r4, CPSR
 688:	f10c0080 	cpsid	i
 68c:	e10f3000 	mrs	r3, CPSR
 690:	e3833080 	orr	r3, r3, #128	; 0x80
 694:	e121f003 	msr	CPSR_c, r3
	: "=r" (flags), "=r" (tmp) \
	: \
	: "memory", "cc");

	//CKC_CHANGE_STACK_TOP
	__asm__ __volatile__( \
 698:	e1a0500d 	mov	r5, sp
 69c:	e59fd058 	ldr	sp, [pc, #88]	; 6fc <change_mem_clock+0x6fc>
		val &= ~0x1;
		__asm__ volatile("mcr	p15, 0, %0, c1, c0, 0" :: "r" (val));
	}
#endif

	pFunc();
 6a0:	e59f3050 	ldr	r3, [pc, #80]	; 6f8 <change_mem_clock+0x6f8>
 6a4:	e12fff33 	blx	r3
		val |= 0x1;
		__asm__ volatile("mcr	p15, 0, %0, c1, c0, 0" :: "r" (val));
	}
#endif

	__asm__ __volatile__( \
 6a8:	e1a0d005 	mov	sp, r5
	"mov	sp, %0 \n" \
	: \
	: "r" (stk) \
	: "memory", "cc");

	__asm__ __volatile__( \
 6ac:	e121f004 	msr	CPSR_c, r4
 6b0:	f10c0080 	cpsid	i
	: \
	: "r" (flags) \
	: "memory", "cc");

	return 0;
}
 6b4:	e3a00000 	mov	r0, #0
 6b8:	e28dd050 	add	sp, sp, #80	; 0x50
 6bc:	e8bd8df0 	pop	{r4, r5, r6, r7, r8, sl, fp, pc}
 6c0:	00000000 	.word	0x00000000
			6c0: R_ARM_ABS32	_change_mem_clock
 6c4:	016e3600 	.word	0x016e3600
 6c8:	10004000 	.word	0x10004000
 6cc:	00000000 	.word	0x00000000
			6cc: R_ARM_ABS32	.rodata.str1.1
 6d0:	0000001b 	.word	0x0000001b
			6d0: R_ARM_ABS32	.rodata.str1.1
 6d4:	00000031 	.word	0x00000031
			6d4: R_ARM_ABS32	.rodata.str1.1
 6d8:	000f4240 	.word	0x000f4240
 6dc:	0000003c 	.word	0x0000003c
			6dc: R_ARM_ABS32	.rodata.str1.1
 6e0:	0000004c 	.word	0x0000004c
			6e0: R_ARM_ABS32	.rodata.str1.1
 6e4:	007704bf 	.word	0x007704bf
 6e8:	0003f79f 	.word	0x0003f79f
 6ec:	ff000002 	.word	0xff000002
 6f0:	00041eb0 	.word	0x00041eb0
 6f4:	00fff001 	.word	0x00fff001
 6f8:	10003000 	.word	0x10003000
 6fc:	10010000 	.word	0x10010000
